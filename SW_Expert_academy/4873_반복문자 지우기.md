# 내 코드
```py
T = int(input())
for stage in range(1, T+1):
    words = list(input())
    p = 0
    n = 1
    while True:
        if n == (len(words)):
            break
        while (p>=0 and n>=1) and (words[p] == words[n]):
            if (n+1) < len(words):
                words[p] = words[n+1]
                words.pop(n+1)
                words.pop(n)
                n -= 1
                p -= 1
            else:
                words.pop(p)
                p -= 1
                n -= 1
                words.pop(n)
                n -= 1
                p -= 1
        n += 1
        p += 1
    print(f"#{stage} {len(words)}")
```

# GPT 피드백
시간 복잡도 최악...
- 좋은 시도! 그런데 지금 코드는
    - 인덱스를 직접 움직이며 pop을 많이 쓰는 방식이라 시간복잡도 O(n²) (최악)이고,
    - p, n 이동/경계 처리에서 인덱스 음수/범위 오류가 날 가능성이 높고,
    - 같은 문자 2개 이상 연속(예: AAA)에서 케이스 분기가 복잡해져 버그가 숨어들기 쉬워요.
### 시간복잡도 최악-> POP 많~~이 이용
1. 리스트 중간에서 pop → O(n)
- 파이썬의 list는 동적 배열이라, 끝이 아닌 위치에서 pop(i) 하면 뒤 원소들을 전부 왼쪽으로 한 칸씩 밀어야 해요.
- 즉, pop(i)는 최악 O(n) 입니다.
(네 코드는 words.pop(n+1), words.pop(n)처럼 중간 지점에서 반복적으로 pop을 실행)
2. 그런 pop을 많~이 한다
- 연속 쌍을 지울 때마다 pop을 2번 하고, 지운 뒤에 앞쪽으로 되감기(p -= 1, n -= 1) 하면서 다시 검사하죠.
- 최악의 경우, 길이 n짜리 문자열에서 이런 **중간 pop**이 문자 수에 비례해서 반복됩니다.
→ “최대 O(n)번 삭제 × 삭제당 O(n)” = O(n²)

### 권장 풀이
이 문제는 “인접한 같은 문자 쌍을 지우고, 이어 붙여 새로 생긴 쌍도 또 지운다” → 딱 스택 패턴입니다.
문자를 왼쪽부터 보며, 스택 top과 같으면 pop(삭제), 다르면 push(유지)만 하면 한 번에 끝나요.
이러면 O(n) 에 안정적으로 처리됩니다.
```py
T = int(input())
for tc in range(1, T + 1):
    s = input().strip()  # 공백 안전
    st = []
    for ch in s:
        if st and st[-1] == ch:
            st.pop()      # 인접 중복 제거
        else:
            st.append(ch) # 유지
    print(f"#{tc} {len(st)}")
```
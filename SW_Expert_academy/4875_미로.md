# 내풀이
```py
from collections import deque
T = int(input())
for stage in range(1, T+1):
    N = int(input())
    mat = []
    for i in range(N):
        new = list(map(int, input()))
        if 2 in new:
            x=new.index(2)
            y=i
        mat.append(new)
    q = deque()
    go = [(1, 0), (-1, 0), (0, 1), (0, -1)]
    result = 0
    q.append((x,y))
    # x가 열, y가 행
    while q:
        now = q.popleft()
        now_x = now[0]
        now_y = now[1]
        if mat[now_y][now_x] == 0:
            mat[now_y][now_x] = 1
        for dx, dy in go:
            next_x = now_x + dx
            next_y = now_y + dy
            if (0 <= next_x < N) and (0 <= next_y < N):
                if mat[next_y][next_x] == 3:
                    result = 1
                    break
                elif mat[next_y][next_x] == 0:
                    q.append((next_x, next_y))
    print(f"#{stage} {result}")
```
# GPT 피드백
### 핵심피드백
1. 방문 체크 타이밍
- 지금은 popleft()한 뒤 현재 칸이 0이면 그때 1로 바꾸고 있어요.
- 이렇게 하면 같은 칸이 큐에 여러 번 들어갈 수 있어요(중복 방문).
→ enqueue 시점(큐에 넣을 때) 바로 방문 처리(벽처럼 표시 or visited=True)를 권장.

2. 도착(3) 발견 시 조기 종료
- 현재는 result=1로 바꾸고 for만 break → 바깥 while은 계속 돔.
→ 도착하면 즉시 전체 BFS 종료가 더 효율적.
3. 시작점(2) 처리 일관성
- 시작점은 방문 확정이니, 큐에 넣을 때 방문 처리를 같이 해두면 깔끔.

```py
from collections import deque

T = int(input())
for stage in range(1, T+1):
    N = int(input())
    mat = []
    sx = sy = -1
    for i in range(N):
        row = list(map(int, input()))   # "0010203..." 형태 가정
        if 2 in row:
            sx = row.index(2)  # 열
            sy = i             # 행
        mat.append(row)

    q = deque()
    q.append((sx, sy))
    # 방문처리: 시작점도 바로 처리 (벽처럼 1로)
    # 2를 그대로 두어도 기능상 문제는 없지만, 일관성을 위해 방문표시 권장
    mat[sy][sx] = 1

    dirs = [(1,0), (-1,0), (0,1), (0,-1)]
    result = 0

    while q:
        x, y = q.popleft()
        for dx, dy in dirs:
            nx, ny = x + dx, y + dy
            if 0 <= nx < N and 0 <= ny < N:
                if mat[ny][nx] == 3:
                    result = 1
                    q.clear()          # 큐 비우고
                    break              # for 탈출
                if mat[ny][nx] == 0:
                    mat[ny][nx] = 1    # **enqueue 전에 방문표시**
                    q.append((nx, ny))
        if result == 1:
            break                      # while 탈출

    print(f"#{stage} {result}")
```
### 기억!
- BFS는 모든 노드 한번씩만 방문해서 방문 처리 돌릴 필요X
- DFS는 돌릴 필요O
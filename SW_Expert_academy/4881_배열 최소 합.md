# 내코드
```py
import copy
T = int(input())
for stage in range(1, T+1):
    n = int(input())
    matrix = []
    saved_index = []
    for i in range(n):
        new_list = list(map(int, input().split()))
        matrix.append(new_list)
        check_index = new_list.index(min(new_list))
        saved_index.append(check_index)
        while True:
            test = set(saved_index)
            if len(test) == len(saved_index):
                break
            previous_index = saved_index.index(check_index) # 몇번째 행에서 이 인덱스의 값이 가장 작은가
            previous_value = matrix[previous_index][check_index]
            now_value = matrix[i][check_index]
            test_matrix = copy.deepcopy(matrix)
            test_matrix[previous_index][check_index] = 11
            test_matrix[i][check_index] = 11
            new_previous_index = test_matrix[previous_index].index(min(test_matrix[previous_index]))
            new_now_index = test_matrix[i].index(min(test_matrix[i]))
            if (previous_value + matrix[i][new_now_index]) < (matrix[previous_index][new_previous_index] + now_value):
                saved_index[i] = new_now_index
                matrix[i][check_index] = 11
                check_index = new_now_index
            else:
                saved_index[previous_index] = new_previous_index
                matrix[previous_index][check_index] = 11
                check_index = new_previous_index
                i = previous_index
    result = 0
    for i, j in enumerate(saved_index):
        result += matrix[i][j]
    print(f"#{stage} {result}")
```
-> 5개 오답
# GPT 피드백
### 왜 틀렸나?
1. 전역 최적 보장 불가(그리디 한계): 각 행에서 최소값을 먼저 고르고, 같은 열 충돌이 나면 뒤에서 수선하는 방식은 전체 최솟값을 보장하지 못해. 예를 들어 여러 행이 같은 열의 값이 아주 작고, 다른 열 값 분포가 제각각인 경우엔 “처음 선택을 되돌리고 전체를 재탐색”해야 하는데, 현재 로직은 국소적으로만 바꾸다 보니 최적해를 놓쳐.
2. 값 덮어쓰기(11로 바꿈) 때문에 합계가 왜곡됨: 충돌 해결 과정에서 matrix[?][?] = 11로 고쳐 놓고, 마지막에 그 수정된 행렬로 합을 구하고 있어. 그러면 실제 선택한 값이 아니라 임시로 올려둔 값이 섞여서 합이 커져 버려(정답 오염).
3. 시간 초과 유발 포인트
- 매 충돌 루프에서 copy.deepcopy(matrix)가 반복됨 → 매우 느림.
- while True + 다단계 재계산 구조가 최악 케이스에서 길게 돌아.
- list.index(min(list))를 반복해 쓰는 것도 누적 비용 큼.
4. 인덱스/흐름 버그 가능성: i = previous_index로 바꾸어도 바깥쪽 for i in range(n) 흐름에는 영향이 제한적이라(다음 반복에서 i가 다시 증가), 의도와 다르게 진행될 수 있어.
### 권장 풀이(정석): 백트래킹 + 가지치기
- 이 문제는 N≤10이라, **DFS(백트래킹)**에 강한 가지치기를 넣으면 2초 제한 내에 충분히 통과돼. <br>핵심은:
- 열 재사용 금지: used[col]로 체크
- 현재까지 합 cur가 최적해 best보다 크면 즉시 중단(가지치기)
- 행 별 최소값의 누적 하한(lower bound)을 미리 계산해 추가 가지치기
```py
import sys
input = sys.stdin.readline

T = int(input())
for tc in range(1, T+1):
    n = int(input().strip())
    a = [list(map(int, input().split())) for _ in range(n)]

    # 각 행의 최소값 (남은 행들의 합에 대한 하한으로 사용)
    row_min = [min(row) for row in a]
    # 뒤에서부터 남은 행들의 최소 합 누적(하한)
    tail_min = [0]*(n+1)
    for r in range(n-1, -1, -1):
        tail_min[r] = tail_min[r+1] + row_min[r]

    used = [False]*n
    best = 10**9

    def dfs(r, cur):
        nonlocal best
        # 가지치기 1: 현재 합 + 남은 행들의 최소 가능한 합 ≥ best면 중단
        if cur + tail_min[r] >= best:
            return
        if r == n:
            best = cur
            return
        # 작은 값부터 시도하면 더 빨리 best를 갱신 → 가지치기 효과 ↑
        # 정렬 비용은 작고, 성능에 보통 이득
        for c, val in sorted(enumerate(a[r]), key=lambda x: x[1]):
            if not used[c]:
                used[c] = True
                dfs(r+1, cur + val)
                used[c] = False

    dfs(0, 0)
    print(f"#{tc} {best}")

```
### 개념!
#### 1) 백트래킹이 뭔데?
- 완전탐색은 모든 경우의 수를 끝까지 다 가보는 방식(여기선 행마다 N가지 선택 → 최대 N! 조합).
- 백트래킹은 “도중에 이미 최적보다 나빠질 게 확실한 경로”를 일찍 중단해서, 실질 탐색 수를 크게 줄인다.
- 즉, “결정(choose) → 진행(explore) → 철회(un-choose)”의 패턴으로 DFS를 하면서, 불가능/불리한 가지를 빠르게 버리는 전략이다.
#### 2) 문제를 백트래킹으로 모델링
- 행 r에서 “어느 열 c를 고를지”를 결정한다.
- 열은 중복 사용 불가 → used[c]로 사용 여부를 체크한다.
- r이 n에 도달하면(모든 행에서 선택 완료) 누적합 cur가 하나의 후보해이고, 전역 최솟값 best를 갱신한다.

#### 3) 가지치기의 근거(하한, lower bound)
- row_min[r] = a[r]의 최소값 : 행 r에서 최소로 기대할 수 있는 비용
- tail_min[r] = row_min[r] + row_min[r+1] + ... + row_min[n-1] : “지금 r행부터 끝까지” 남은 행들이 아무리 잘 골라도 최소 이만큼 든다는 하한
- 현재까지의 합이 cur일 때, 앞으로 최소로 더해도 cur + tail_min[r]가 된다.
- 만약 cur + tail_min[r] >= best라면? → 이 가지는 더 가봐야 현재 best보다 나을 가능성이 0.
그래서 return으로 즉시 중단한다. (이게 성능의 핵!)

#### 4) 코드 각 부분이 하는 일
- row_min 계산: 각 행의 최솟값을 미리 뽑아둔다(하한 계산용).
- tail_min 누적: 뒤에서 앞으로 누적해 두면, DFS 중에 O(1)로 “남은 최소 합”을 꺼내 쓸 수 있다.
- used = [False]*n: 열 재사용 막기(세로 중복 금지 조건).
- best = 10**9: 현재까지 찾은 최적해(초기엔 큰 값).

- dfs(r, cur):

    - 가지치기 1: cur + tail_min[r] >= best면 컷.
    - 종료 조건: r == n이면 전 행 선택 완료 → best = cur.
    - 탐색 순서: for c, val in sorted(enumerate(a[r]), key=lambda x: x[1]) 현재 행에서 값이 작은 열부터 시도한다. 그러면 더 이른 시점에 작은 합으로 best를 갱신할 확률이 커지고, 그 다음 가지치기들이 더 공격적으로 작동해 속도가 더 빨라진다.
    - 선택/철회: used[c] = True로 선택 후 재귀, 돌아오면 False로 원복. 이 패턴이 백트래킹의 전형.
# 내코드
```py
import copy
T = int(input())
for stage in range(1, T+1):
    n = int(input())
    matrix = []
    saved_index = []
    for i in range(n):
        new_list = list(map(int, input().split()))
        matrix.append(new_list)
        check_index = new_list.index(min(new_list))
        saved_index.append(check_index)
        while True:
            test = set(saved_index)
            if len(test) == len(saved_index):
                break
            previous_index = saved_index.index(check_index) # 몇번째 행에서 이 인덱스의 값이 가장 작은가
            previous_value = matrix[previous_index][check_index]
            now_value = matrix[i][check_index]
            test_matrix = copy.deepcopy(matrix)
            test_matrix[previous_index][check_index] = 11
            test_matrix[i][check_index] = 11
            new_previous_index = test_matrix[previous_index].index(min(test_matrix[previous_index]))
            new_now_index = test_matrix[i].index(min(test_matrix[i]))
            if (previous_value + matrix[i][new_now_index]) < (matrix[previous_index][new_previous_index] + now_value):
                saved_index[i] = new_now_index
                matrix[i][check_index] = 11
                check_index = new_now_index
            else:
                saved_index[previous_index] = new_previous_index
                matrix[previous_index][check_index] = 11
                check_index = new_previous_index
                i = previous_index
    result = 0
    for i, j in enumerate(saved_index):
        result += matrix[i][j]
    print(f"#{stage} {result}")
```
-> 5개 오답
# GPT 피드백
### 왜 틀렸나?
1. 전역 최적 보장 불가(그리디 한계): 각 행에서 최소값을 먼저 고르고, 같은 열 충돌이 나면 뒤에서 수선하는 방식은 전체 최솟값을 보장하지 못해. 예를 들어 여러 행이 같은 열의 값이 아주 작고, 다른 열 값 분포가 제각각인 경우엔 “처음 선택을 되돌리고 전체를 재탐색”해야 하는데, 현재 로직은 국소적으로만 바꾸다 보니 최적해를 놓쳐.
2. 값 덮어쓰기(11로 바꿈) 때문에 합계가 왜곡됨: 충돌 해결 과정에서 matrix[?][?] = 11로 고쳐 놓고, 마지막에 그 수정된 행렬로 합을 구하고 있어. 그러면 실제 선택한 값이 아니라 임시로 올려둔 값이 섞여서 합이 커져 버려(정답 오염).
3. 시간 초과 유발 포인트
- 매 충돌 루프에서 copy.deepcopy(matrix)가 반복됨 → 매우 느림.
- while True + 다단계 재계산 구조가 최악 케이스에서 길게 돌아.
- list.index(min(list))를 반복해 쓰는 것도 누적 비용 큼.
4. 인덱스/흐름 버그 가능성: i = previous_index로 바꾸어도 바깥쪽 for i in range(n) 흐름에는 영향이 제한적이라(다음 반복에서 i가 다시 증가), 의도와 다르게 진행될 수 있어.
### 권장 풀이(정석): 백트래킹 + 가지치기
- 이 문제는 N≤10이라, **DFS(백트래킹)**에 강한 가지치기를 넣으면 2초 제한 내에 충분히 통과돼. <br>핵심은:
- 열 재사용 금지: used[col]로 체크
- 현재까지 합 cur가 최적해 best보다 크면 즉시 중단(가지치기)
- 행 별 최소값의 누적 하한(lower bound)을 미리 계산해 추가 가지치기
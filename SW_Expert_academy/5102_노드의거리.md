# 내풀이
### 1번째 시도
```py
T = int(input())
for stage in range(1, T+1):
    V, E = map(int, input().split())
    graph = {i:[] for i in range(1, V+1)}
    for _ in range(E):
        a,b = map(int, input().split())
        graph[a].append(b)
        graph[b].append(a)
    S,G = map(int, input().split())
    visited = [False] * (V+1)
    visited[S] = True
    min_distance = 1001
    stack = [[S,0,visited]]
    while stack:
        now = stack.pop()
        if now[0] == G:
            if now[1] < min_distance:
                min_distance = now[1]
        else:
            if len(graph[now[0]]) != 0:
                for next in graph[now[0]]:
                    if (not now[2][next]) and (next != now[0]):
                        copy_visited = now[2].copy()
                        copy_visited[next] = True
                        stack.append([next, now[1] + 1, copy_visited])

    print(f"#{stage} {min_distance}")
```
- 제한 시간 초과..

### 2번째 시도
```py
T = int(input())
for stage in range(1, T+1):
    V, E = map(int, input().split())
    graph = {i:[] for i in range(1, V+1)}
    for _ in range(E):
        a,b = map(int, input().split())
        graph[a].append(b)
        graph[b].append(a)
    S,G = map(int, input().split())
    visited = [False] * (V+1)
    visited[S] = True
    min_distance = 1001
    stack = [[S,0]]
    while stack:
        now = stack.pop()
        if now[0] == G:
            if now[1] < min_distance:
                min_distance = now[1]
        else:
            if len(graph[now[0]]) != 0:
                for next in graph[now[0]]:
                    if (not visited[next]) and (next != now[0]):
                        visited[next] = True
                        stack.append([next, now[1] + 1])
    if min_distance == 1001:
        min_distance = 0
    print(f"#{stage} {min_distance}")
```
=> 2개 계속틀림...

# GPT 조언
문제는 DFS(스택) 로 최소 간선 수(=최단 거리)를 구하려고 한 점이에요.
무가중치 그래프에서 최단 간선 수는 BFS(큐, 레벨 순회) 로만 보장됩니다. 지금 코드는 방문을 True로 고정하면서 DFS를 타기 때문에, 더 짧은 경로가 나중에 발견되어도 이미 방문 처리되어 짧은 경로를 버리는 경우가 생겨요. 그래서 몇 케이스가 틀린 겁니다.

또한 (next != now[0]) 체크는 자기 자신으로의 자가 루프가 아닌 이상 불필요합니다.

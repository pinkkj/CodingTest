# IDEA
요건 SWEA의 “이진탐색(완전 이진 트리 채우기)” 류 문제예요.
핵심 아이디어만 잡으면 아주 간단합니다.
- 정의 확인: “왼쪽 서브트리”는 왼쪽 자식만이 아니라, 왼쪽 자식을 루트로 하는 모든 하위 노드 전체를 말해요.
- 완전 이진 트리의 인덱싱은 1이 루트, i의 왼쪽 자식 2*i, 오른쪽 자식 2*i+1.
- BST가 정렬 규칙을 만족하려면 중위 순회(inorder)(정의: 중위 순회 = 왼쪽 서브트리 → 현재 노드 → 오른쪽 서브트리 순서로 방문하는 트리 순회.) 했을 때 값이 오름차순이어야 하죠.
- 그래서 트리의 노드를 중위 순회 순서대로 1..N을 채워 넣으면, 그 트리가 바로 원하는 BST가 됩니다.
- 다 채운 뒤 루트 값은 tree[1], 그리고 **N//2번 노드 값은 tree[N//2]**를 출력하면 돼요.

```py
import sys
input = sys.stdin.readline

T = int(input().strip())
for tc in range(1, T + 1):
    N = int(input().strip())
    tree = [0] * (N + 1)
    cnt = 1

    sys.setrecursionlimit(10**6)

    def inorder(i):
        nonlocal cnt
        if i > N:
            return
        inorder(i * 2)          # 왼쪽 서브트리
        tree[i] = cnt           # 현재 노드에 값 채우기
        cnt += 1
        inorder(i * 2 + 1)      # 오른쪽 서브트리

    inorder(1)
    print(f"#{tc} {tree[1]} {tree[N // 2]}")
```
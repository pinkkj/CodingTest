# 내 풀이
```py
T = int(input())
for stage in range(1, T + 1):
    N = int(input())
    info = list(map(int, input().split()))
    result = 0
    start = 0
    while True:
        max_val = info.index(max(info))
        new_info = info[start:max_val+1]
        if len(new_info) == 1:
            info[max_val] = 0
            if max_val < N-2:
                start = max_val + 1
            else:
                break
        else:
            for i in range(start, max_val):
                result += (info[max_val] - info[i])
            info[max_val] = 0

            if max_val < N-2:
                start = max_val + 1
            else:
                break
    print(f"#{stage} {result}")
```
=> 타임 아웃..왜지?

```py
T = int(input())
for stage in range(1, T + 1):
    N = int(input())
    info = list(map(int, input().split()))
    result = 0
    def buy(val):
        if len(val) == 1:
            return 0

        max_index = val.index(max(val))
        if 0 <= max_index < len(val) - 1:
            return buy(val[:max_index+1]) + buy(val[max_index+1::])
        elif max_index == len(val) - 1:
            gain = 0
            for i in range(max_index):
                gain += val[max_index] - val[i]
            return gain

    result = buy(info)
    print(f"#{stage} {result}")
```
=> 분할 정복 방법으로 변경<br>
=> 10/7 -> runtime error

```py
T = int(input())
for stage in range(1, T + 1):
    N = int(input())
    info = list(map(int, input().split()))
    result = 0
    def buy(val):
        if (len(val) == 1) or (sorted(val, reverse=True) == val):
            return 0

        max_index = val.index(max(val))
        if 0 <= max_index < len(val) - 1:
            return buy(val[:max_index+1]) + buy(val[max_index+1::])

        elif max_index == len(val) - 1:
            gain = 0
            for i in range(max_index):
                gain += val[max_index] - val[i]
            return gain

    result = buy(info)
    print(f"#{stage} {result}")
```
# GPT 피드백
### 왜 runtime error?
1. buy()가 재귀 + 슬라이싱을 씁니다.
    - val[:max_index+1], val[max_index+1::]가 매 호출마다 새 리스트를 만들어서 메모리/시간을 크게 잡아먹습니다.
    - 최악의 경우 O(N²) 가까이 됩니다.
2. sorted(val, reverse=True) == val로 “내림차순 여부”를 매번 검사 → 이것도 O(N log N).
3. val.index(max(val))가 가장 처음 나오는 max의 인덱스를 줍니다. 최대가 여러 번이면 “마지막 최대일에 몰아팔기” 전략이 깨집니다.
4. N이 최대 1,000,000이므로 재귀는 깊이 제한에 부딪힐 수 있습니다.
### 정해: 뒤에서부터 최대값 유지 (O(N), 비재귀)
- 오른쪽(마지막 날)에서 왼쪽으로 보면서, 지금까지 본 최대값을 유지합니다.
오늘 가격이 최대값보다 작으면 (최대값 - 오늘가격)만큼 이득이 생깁니다(그날 1개씩 사왔다가 최대값 날에 판 것으로 해석).
```py
import sys
input = sys.stdin.readline

T = int(input().strip())
for tc in range(1, T + 1):
    N = int(input().strip())
    prices = list(map(int, input().split()))

    max_so_far = 0
    profit = 0

    # 뒤에서 앞으로 훑는다
    for p in reversed(prices):
        if p > max_so_far:
            max_so_far = p      # 앞으로는 이 날에 몰아판다
        else:
            profit += (max_so_far - p)  # 오늘 1개 산 걸 나중에 판 이익

    print(f"#{tc} {profit}")
```
### 이문제를 보고 딱 예를 들어 1 1 3 1 2 면 [1 1 3] [1 1 2]로 나누어 팔면 된다 생각하여 분할 정복을 생각해서 재귀를 생각해냈어. 재귀인지 이것처럼 for문을 써야하는진 내가 어떻게 판단해?

좋은 관찰이야! 이 문제는 직관적으로 “최대가가 있는 구간들로 쪼개서 산 걸 마지막에 몽땅 판다”로 보이니까 분할정복(재귀)이 떠오르기 쉬워. 그런데 **파이썬 + N 최대 10⁶** 조건에선 재귀보다 단일 스캔(그리디, 반복문)이 훨씬 안전하고 빠릅니다. 판단 기준을 정리해볼게.
### 언제 재귀 말고 for(반복)로 가야 하나?
1. 입력 크기·제한
- N이 10⁶ 같은 초대형이면:
    - 파이썬은 꼬리 재귀 최적화가 없음 → 깊은 재귀는 RecursionError 위험.
    - 슬라이싱/정렬/부분리스트 생성이 섞이면 시간·메모리 폭증.<br>

→ 이런 경우 O(N) 한 번 스캔 + O(1) 추가 메모리가 정답 패턴.

2. 문제 구조(미래 정보를 한 기준으로만 보면 되나?)
- 이 문제의 핵심은 “오른쪽에서 봤을 때 최대가”에 비해 오늘 가격이 얼마나 싼가만 보면 이득이 바로 정해진다.
- 즉, 미래의 최대값 하나만 알면 매일의 의사결정이 독립적으로 끝난다 → 분할정복으로 쪼갤 필요 X, 전역 기준으로 선형 스캔 O.

3. 서브문제 간 독립성
- 분할정복이 맞는지는 “경계가 잘린 뒤에도 각 구간의 최적해가 서로 간섭하지 않느냐”로 판단.
- 여기선 “마지막으로 파는 날(미래 최대가가 있는 날)”이 구간 경계를 가로질러 전역적으로 결정됨.
- 구간을 잘라서 왼쪽 최댓값 날과 오른쪽 최댓값 날을 따로 최적화하면 전역 최댓값에 비해 놓치는 이득이 생길 수 있음. → 재귀 분할이 자연스럽지 않음.

4. 시간복잡도 신호
- 재귀 안에서 max, index, sorted, 슬라이싱이 보이면 거의 항상 O(N log N)~O(N²) 경보.
- 반면 뒤에서 앞으로 한 번 훑는 그리디는 O(N).

### 왜 “뒤에서 앞으로 한 번”이 그리디 정해인가? (짧은 증명 스케치)
- 어떤 날 i에 산 물건은 i 이후의 날 중 최댓값 M에 파는 것이 항상 최선. (더 낮은 날에 팔 이유가 없음)
- 따라서 각 i에 대한 이득은 max(0, M - price[i]).
- 이것을 모든 i에 대해 더하면 끝 → 뒤에서 보며 max_so_far만 유지하면 된다.

### “재귀가 정말 맞는 문제”는 언제?
- 경계로 나누면 서브문제를 독립적으로 풀고(최적 부분 구조), 결과를 작게 합쳐 전역 해를 만들 수 있을 때.
    - 예) 병합정렬(정렬 결과 병합), 분할정복 최대 구간합(왼/오/가운데 세 경우만 비교), 최근접 점쌍 등.
- 그리고 깊이 제한/언어 특성이 허용될 때(C/C++처럼 스택 넉넉하거나, 깊이가 log N 수준일 때).

### 빠른 실전 체크리스트
- N이 크다(≥ 10⁵~10⁶): 재귀 피하고 반복문 O(N) 우선.
- 미래 기준 하나(또는 소수의 상태)만으로 현재 의사결정이 가능: 한 방향 스캔 그리디 후보.
- 재귀 안에서 슬라이싱/정렬/index(max()) 같은 선형·로그항 반복: 위험.
- 경계 잘라도 서로 간섭 없음 + 합치기 쉬움: 분할정복 후보.
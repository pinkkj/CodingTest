# 내코드
```py
T = int(input())
def check(i,j,N,mat):
    if (0<= i < N) and (0<=j<N) and (mat[i][j] == 0):
        return True
    else:
        return False

for stage in range(1, T+1):
    N = int(input())
    info = [[0]*N for _ in range(N)]
    go_row = False
    go_col = True
    add = 1
    i = 0
    j = 0
    turn = 0
    for val in range(1, N*N+1):
        info[i][j] = val
        if go_col:
            if check(i, j+add, N, info):
                j += add
            else:
                if turn != 1:
                    turn += 1
                else:
                    turn = 0
                    add = -add
                i += add
                go_col = False
                go_row = True
        elif go_row:
            if check(i+add, j, N, info):
                i += add
            else:
                if turn != 1:
                    turn += 1
                else:
                    turn = 0
                    add = -add
                j += add
                go_col = True
                go_row = False
    print(f"#{stage}")
    for i in range(N):
        for j in range(N):
            print(info[i][j], end=" ")
        print()
```
# GPT 피드백
## 스타일/가독성 측면에서 살짝만 손보면 좋은 점
### 2-1. check 함수 단축
```py
def check(i, j, N, mat):
    return 0 <= i < N and 0 <= j < N and mat[i][j] == 0
```

### 2-2. 방향 관리 방식 (지금도 되지만, 대안도 한번 봐봐)
지금은
- go_row, go_col 두 개의 bool
- add : +1 / -1
- turn : 0/1

이 셋으로 방향을 관리하는데, 약간 “머리로 따라가야 하는” 느낌이 있어서,
코테에서 자주 쓰는 대표 패턴은 이렇게 해:

```py
dirs = [(0,1), (1,0), (0,-1), (-1,0)]  # 오른쪽, 아래, 왼쪽, 위
d = 0  # 현재 방향 인덱스

i, j = 0, 0
for val in range(1, N*N+1):
    info[i][j] = val
    ni = i + dirs[d][0]
    nj = j + dirs[d][1]
    if not (0 <= ni < N and 0 <= nj < N and info[ni][nj] == 0):
        d = (d + 1) % 4  # 방향 전환
        ni = i + dirs[d][0]
        nj = j + dirs[d][1]
    i, j = ni, nj
```
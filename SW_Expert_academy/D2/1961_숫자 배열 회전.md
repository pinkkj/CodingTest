# 내코드
```py
import copy
T = int(input())
for stage in range(1, T+1):
    result = []
    N = int(input())
    now_list = [list(map(int, input().split())) for _ in range(N)]
    row = 0
    col = N-1
    rotate = 90
    new_list = [[0] * N for _ in range(N)]
    while rotate != 360:
        edit_row = row
        edit_col = col
        new_list = [[0] * N for _ in range(N)]
        for i in range(N):
            for j in range(N):
                new_list[i+edit_row][j+edit_col] = now_list[i][j]
                edit_row += 1
                edit_col -= 1
            edit_row -= N + 1
            edit_col += N-1
        result.append(new_list)
        now_list = copy.deepcopy(new_list)
        rotate += 90
    print(f"#{stage}")
    for i in range(N):
        for j in range(3):
            for z in range(N):
                print(result[j][i][z], end="")
            print(" ", end="")
        print()
```
# GPT 피드백

## 1. 현재 코드에서 아쉬운 부분
### (1) 회전 로직
- i+edit_row, j+edit_col로 계속 대각선 방향으로 이동시키는 방식인데, 이것은 “행렬 회전”이 아니라 약간 기묘한 “슬라이딩”에 더 가깝고, 인덱스 에러 위험도 커.
- 실제로 90도 회전은 단순히
    - new[i][j]=old[N−1−j][i] 처럼 정해진 공식만 쓰면 돼. 굳이 row, col, edit_row, edit_col을 따로 들고 있을 필요가 없어.
### (2) shallow copy 고민
그래서 선택지는 둘 중 하나야.

1. 회전할 때마다 항상 새로운 리스트 생성 (가장 깔끔)
2. copy.deepcopy 사용 (하지만 이 문제 규모에선 굳이 이렇게까지 안 해도 됨)

나는 1번처럼 아예 rotate90() 함수 안에서 새 리스트 만들어서 반환하는 걸 추천해.

## 2. 출력 부분 (시간 복잡도 & 깔끔하게 쓰기)
```py
for i in range(N):
    line_parts = []
    for k in range(3):  # 90, 180, 270
        line_parts.append("".join(map(str, result[k][i])))
    print(" ".join(line_parts))
```
## 3. 추천하는 “다른 방법” (깔끔 버전)
### 3-1. 90도 회전 함수 작성
```py
def rotate90(matrix):
    N = len(matrix)
    # new[i][j] = old[N-1-j][i]
    return [[matrix[N - 1 - j][i] for j in range(N)] for i in range(N)]
```
### 3-2. 전체 코드 예시
```py
import sys
input = sys.stdin.readline  # SW Expert면 보통 이렇게 쓰면 I/O 살짝 더 빠름

def rotate90(matrix):
    N = len(matrix)
    return [[matrix[N - 1 - j][i] for j in range(N)] for i in range(N)]

T = int(input())
for tc in range(1, T + 1):
    N = int(input())
    now = [list(map(int, input().split())) for _ in range(N)]

    r90 = rotate90(now)
    r180 = rotate90(r90)
    r270 = rotate90(r180)
    rots = [r90, r180, r270]

    print(f"#{tc}")
    for i in range(N):
        line_parts = []
        for k in range(3):  # 90, 180, 270
            line_parts.append("".join(map(str, rots[k][i])))
        print(" ".join(line_parts))
```
# 다른 사람 코드
1.
```py
def rotate(arr):
    arrR = [[0]*N for _ in range(N)]
    for i in range(N):
        for j in range(N):
            arrR[i][j] = arr[N-1-j][i]
 
    return arrR
 
 
 
T = int(input())
for test_case in range(1, T + 1):
    N = int(input())
    arr = [list(map(int, input().split())) for _ in range(N)]
    arr1 = rotate(arr)
    arr2 = rotate(arr1)
    arr3 = rotate(arr2)
 
    print(f'#{test_case} ')
    for a,b,c in zip(arr1, arr2, arr3):
        print(f'{"".join(map(str, a))} {"".join(map(str, b))} {"".join(map(str, c))}')
```
=> 아하! zip 이용과 "".join으로 출력!!

2. 
```py
def rotate(arr, N):
    return [[arr[N-1-j][i] for j in range(N)] for i in range(N)]
 
 
T = int(input())
 
for tc in range(1, T+1):
    N = int(input())
    arr = [list(map(int, input().split())) for _ in range(N)]
 
    rot90 = rotate(arr, N)
    rot180 = rotate(rot90, N)
    rot270 = rotate(rot180, N)
 
 
    print(f"#{tc}")
    for i in range(N):
        r90 = ''.join(map(str, rot90[i]))
        r180 = ''.join(map(str, rot180[i]))
        r270 = ''.join(map(str, rot270[i]))
        print(r90, r180, r270)
```
=> 여기도 ''.join으로 출력!!
# 내 코드
```py
T = int(input())
for stage in range(1, T+1):
    N, K = map(int, input().split())
    info = [[0]*(N+2) for _ in range(N)]
    re_info = [[0]*(N+2) for _ in range(N)]
    input_info = [list(map(int, input().split())) for _ in range(N)]
    re_input_info = list(list(zip(*input_info)))
    for i in range(N):
        info[i][1:N+1] = input_info[i]
        re_info[i][1:N+1] = re_input_info[i]
    result = 0
    for i in range(N):
        for j in range(1, N-1):
            if (info[i][j] == 1) and (info[i][j-1] == 0) and (info[i][j+3] == 0):
                if sum(info[i][j:j+3]) == 3:
                    result += 1
            if (re_info[i][j] == 1) and (re_info[i][j-1] == 0) and (re_info[i][j+3] == 0):
                if sum(re_info[i][j:j+3]) == 3:
                    result += 1
    print(f"#{stage} {result}")
```
=> 10/6 정답(아, 난 바보다. 3으로 하드코딩 되어있음)
```py
T = int(input())
for stage in range(1, T+1):
    N, K = map(int, input().split())
    info = [[0]*(N+2) for _ in range(N)]
    re_info = [[0]*(N+2) for _ in range(N)]
    input_info = [list(map(int, input().split())) for _ in range(N)]
    re_input_info = list(list(zip(*input_info)))
    for i in range(N):
        info[i][1:N+1] = input_info[i]
        re_info[i][1:N+1] = re_input_info[i]
    result = 0

    for i in range(N):
        for j in range(1, N-(K-2)):
            if (info[i][j] == 1) and (info[i][j-1] == 0) and (info[i][j+K] == 0):
                if sum(info[i][j:j+K]) == K:
                    result += 1
            if (re_info[i][j] == 1) and (re_info[i][j-1] == 0) and (re_info[i][j+K] == 0):
                if sum(re_info[i][j:j+K]) == K:
                    result += 1
    print(f"#{stage} {result}")
```
=> 아하...다시 풀어보자
# GPT 피드백
## 개선 포인트
### 2-3. 중복 로직 함수로 빼기 (선택사항)
```py
def count_in_board(board, N, K):
    cnt = 0
    for i in range(N):
        for j in range(1, N - K + 2):
            if (board[i][j] == 1 
                and board[i][j-1] == 0 
                and board[i][j+K] == 0 
                and sum(board[i][j:j+K]) == K):
                cnt += 1
    return cnt
```
```py
result = count_in_board(info, N, K) + count_in_board(re_info, N, K)
```
## 3. 다른 풀이 방식(참고용)
지금 풀이는 완전 괜찮은데, SWEA에서는 보통 “연속된 1의 길이”를 세는 방식도 많이 써:
```py
def count_line(line, K):
    cnt = 0
    length = 0
    for v in line + [0]:  # 끝에 0 하나 더 붙여서 마지막 블록 처리
        if v == 1:
            length += 1
        else:
            if length == K:
                cnt += 1
            length = 0
    return cnt
```
```py
result = 0
for i in range(N):
    result += count_line(input_info[i], K)             # 가로
for j in range(N):
    col = [input_info[i][j] for i in range(N)]
    result += count_line(col, K)                      # 세로
```
# 다른사람 풀이
1.
```py
T = int(input())
 
for tc in range(1, T + 1):
    N, M = map(int, input().split())
    arr = [list(map(int, input().split())) for _ in range(N)]
    cnt = 0
 
    for i in range(N):
        num = 0
        for j in range(N):
            if arr[i][j] == 1:
                num += 1
            else:
                if num == M:
                    cnt += 1
                num = 0
        if num == M:
            cnt += 1
 
    for i in range(N):
        num = 0
        for j in range(N):
            if arr[j][i] == 1:
                num += 1
            else:
                if num == M:
                    cnt += 1
                num = 0
        if num == M:
            cnt += 1
 
    print(f"#{tc} {cnt}")
```
# 내 코드
```py
T = int(input())
for stage in range(1, T+1):
    grades = ["A+", "A0", "A-", "B+", "B0", "B-", "C+", "C0", "C-", "D0"]
    N, K = map(int, input().split())
    scores = []
    for i in range(1, N+1):
        mid, final, homework = map(int, input().split())
        now = mid*0.35 + final*0.45 + homework*0.2
        scores.append(now)
        if i == K:
            target = now
    scores.sort(reverse=True)
    rank = scores.index(target)
    print(f"#{stage} {grades[rank//(N//10)]}")
```
# GPT 피드백
부동소수점으로 점수를 만들고 list.index()로 찾는 방식은 굳이 위험(정밀도 이슈 가능성)할 필요가 없어.
점수를 정수 스케일로 계산(×100)하고, 학생 번호로 순위를 찾으면 더 견고해.
```py
T = int(input())
grades = ["A+", "A0", "A-", "B+", "B0", "B-", "C+", "C0", "C-", "D0"]

for t in range(1, T + 1):
    N, K = map(int, input().split())
    scores = []
    for i in range(1, N + 1):
        mid, final, hw = map(int, input().split())
        # 부동소수 대신 정수 스케일(%) : 35%, 45%, 20%
        total = mid * 35 + final * 45 + hw * 20   # ← ×100 한 효과
        scores.append((total, i))                 # (점수, 학생번호)

    # 점수 내림차순 정렬
    scores.sort(reverse=True)                     # 동점 없음이 보장되어 안전

    # K번 학생의 등수(0-based) 찾기
    rank = next(idx for idx, (_, i) in enumerate(scores) if i == K)

    # 구간 크기 = N//10
    ans = grades[rank // (N // 10)]
    print(f"#{t} {ans}")
```
# 내 코드
```py
T = int(input())
for stage in range(1, T+1):
    result = 0
    N, M = map(int, input().split())
    info = [list(map(int, input().split())) for _ in range(N)]
    for i in range(N-(M-1)):
        for j in range(N-(M-1)):
            cal = 0
            for mask in range(M):
                cal += sum(info[i+mask][j:j+M])
            if cal > result:
                result = cal
    print(f"#{stage} {result}")
```
# GPT 피드백
- 다만 안쪽에서 sum(info[i+mask][j:j+M])를 매번 새로 계산해서 복잡도 O((N−M+1)^2 · M^2)라 조금 비효율적이야. 두 가지 개선안을 줄게.
### 1) 2D 누적합(프리픽스 합) → 한 칸 O(1)
직사각형 합을 O(1)로 구하므로 전체 O(N^2).
```py
import sys
input = sys.stdin.readline

T = int(input())
for tc in range(1, T+1):
    N, M = map(int, input().split())
    a = [list(map(int, input().split())) for _ in range(N)]

    # ps[r+1][c+1] = (0,0)~(r,c) 합
    ps = [[0]*(N+1) for _ in range(N+1)]
    for r in range(N):
        row_sum = 0
        for c in range(N):
            row_sum += a[r][c]
            ps[r+1][c+1] = ps[r][c+1] + row_sum

    best = 0
    for r in range(N - M + 1):
        for c in range(N - M + 1):
            r2, c2 = r + M, c + M
            total = ps[r2][c2] - ps[r][c2] - ps[r2][c] + ps[r][c]
            if total > best:
                best = total

    print(f"#{tc} {best}")
```

### 2) 슬라이딩 윈도우(행 → 열 두 번) → O(N^2)

먼저 각 행에서 가로 M합을 슬라이딩으로 만들고, 그 결과에 대해 세로 M합을 또 슬라이딩.

```py
import sys
input = sys.stdin.readline

T = int(input())
for tc in range(1, T+1):
    N, M = map(int, input().split())
    a = [list(map(int, input().split())) for _ in range(N)]

    # 1) 각 행에서 가로 M 슬라이딩 합
    row_win = [[0]*(N - M + 1) for _ in range(N)]
    for r in range(N):
        s = sum(a[r][0:M])
        row_win[r][0] = s
        for c in range(1, N - M + 1):
            s += a[r][c+M-1] - a[r][c-1]
            row_win[r][c] = s

    # 2) 위 결과에 대해 세로 M 슬라이딩 합
    best = 0
    for c in range(N - M + 1):
        s = sum(row_win[r][c] for r in range(0, M))
        best = max(best, s)
        for r in range(1, N - M + 1):
            s += row_win[r+M-1][c] - row_win[r-1][c]
            best = max(best, s)

    print(f"#{tc} {best}")
```

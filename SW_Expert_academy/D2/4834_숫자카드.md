# 내 코드

```py
from collections import Counter
T = int(input())
for stage in range(1, T+1):
    num_cards = int(input())
    info = list(map(int, input()))
    info.sort(reverse=True)
    info = Counter(info)
    max = 0
    max_num = 0
    for num, i in info.items():
        if max < i:
            max = i
            max_num = num
    print(f"#{stage} {max_num} {max}")
```
# GPT 피드백
### 개선 포인트
- info.sort(reverse=True)는 불필요해. Counter엔 영향 없고 시간만 듦.
- max라는 변수명은 내장함수 max()를 가린다 → 다른 이름 쓰기.
- 동률 처리가 빠져 있어. 현재 코드는 먼저 본 숫자를 채택하므로 “동률이면 숫자가 큰 쪽” 규칙을 보장하지 못해.
- 입력 줄에 공백이 없으니 list(map(int, input()))는 OK. 그래도 strip()은 습관적으로 붙이는 게 안전.
```py
from collections import Counter

T = int(input().strip())
for stage in range(1, T + 1):
    N = int(input().strip())
    s = input().strip()              # 공백 없이 붙어 있는 숫자들
    cards = list(map(int, s[:N]))    # 혹시 모를 길이 이슈 대비

    cnt = Counter(cards)
    # 동률이면 숫자가 큰 쪽을 고르도록 정렬 기준 설정
    num, freq = max(cnt.items(), key=lambda x: (x[1], x[0]))

    print(f"#{stage} {num} {freq}")
```
```py
T = int(input().strip())
for stage in range(1, T + 1):
    N = int(input().strip())
    s = input().strip()
    counts = [0] * 10
    for ch in s[:N]:
        counts[ord(ch) - 48] += 1  # '0' = 48

    # 동률이면 숫자가 큰 쪽이 이기도록 역순 탐색
    best_num, best_cnt = 0, -1
    for d in range(9, -1, -1):
        if counts[d] > best_cnt:
            best_cnt = counts[d]
            best_num = d

    print(f"#{stage} {best_num} {best_cnt}")
```

# 다른 사람 코드

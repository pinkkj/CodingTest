# 내코드

```py
T = int(input())
for stage in range(1, T+1):
    N, M = map(int, input().split())
    info = list(map(int, input().split()))
    min_val = 10**9
    max_val = 0
    for i in range(0, N-M+1):
        now = sum(info[i:i+M])
        if min_val > now:
            min_val = now
        if max_val < now:
            max_val = now
    print(f"#{stage} {max_val-min_val}")
```
=> ㅋ..처음에 연속된! 이라는거 못보고 맘대로 정렬해놓고 왜틀렸지? 이러고 있었음ㅋㅋ

# 피드백
1. 시간 복잡도
- sum(info[i:i+M])가 매번 O(M)이라 전체가 O(N·M)이야. → 슬라이딩 윈도우로 한 칸 이동할 때 +새 원소 -빠진 원소만 계산하면 O(N)으로 줄일 수 있어.
2. 초깃값 안전성
- 지금은 min_val=10**9, max_val=0으로 두는데, 입력 제약에 의존해(양수)도 되지만
첫 윈도우 합으로 초기화하면 음수/임의 값에도 안전하고 코드 의도가 명확해져.

### 추가팁
- 입력량이 커지면 import sys; input = sys.stdin.readline로 I/O 가속.
- 변수명은 min_sum/max_sum처럼 의도를 드러내는 이름이 읽기 좋아.
```py
import sys
input = sys.stdin.readline

T = int(input())
for stage in range(1, T + 1):
    N, M = map(int, input().split())
    arr = list(map(int, input().split()))

    curr = sum(arr[:M])
    min_sum = curr
    max_sum = curr

    for i in range(M, N):
        curr += arr[i] - arr[i - M]
        if curr < min_sum:
            min_sum = curr
        if curr > max_sum:
            max_sum = curr

    print(f"#{stage} {max_sum - min_sum}")
```
# 내 코드
```py
T = int(input())
for stage in range(1, T+1):
    info = [[0]*10 for _ in range(10)]
    N = int(input())
    result = 0
    for _ in range(N):
        l1, l2, r1, r2, color = map(int, input().split())
        for i in range(l1, r1+1):
            for j in range(l2, r2+1):
                now_val = info[i][j]
                if (now_val == 0) or ((now_val != color) and (now_val != 3)):
                    info[i][j] += color
                    if info[i][j] == 3:
                        result += 1
    print(f"#{stage} {result}")
```
# 피드백
- 색 처리: 지금은 += color로 덧셈을 비트마스크처럼 쓰고 있는데, 의도를 드러내려면 비트 OR(|=)이 딱 맞아.
    - 빨강=1, 파랑=2 → 보라=3(=1|2)
    - “이미 같은 색”이면 중복 OR 되어도 값이 안 바뀌니까 조건문이 단순해짐.
- 보라색 카운트는 직전 값이 3이 아니었는데 갱신 뒤 3이 되었을 때만 +1 하면 가장 안전

```py
T = int(input())
for stage in range(1, T+1):
    info = [[0]*10 for _ in range(10)]
    N = int(input())
    result = 0
    for _ in range(N):
        r1, c1, r2, c2, color = map(int, input().split())
        mask = 1 if color == 1 else 2   # 1(빨강), 2(파랑)
        for r in range(r1, r2 + 1):
            for c in range(c1, c2 + 1):
                prev = info[r][c]
                info[r][c] |= mask
                if prev != 3 and info[r][c] == 3:
                    result += 1
```
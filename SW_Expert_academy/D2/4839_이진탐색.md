# 내 코드
```py
T = int(input())
for stage in range(1, T+1):
    P, Pa, Pb = map(int,input().split())
    start_a, end_a = 1, P
    start_b, end_b = 1, P
    win_a, win_b = False, False
    while (start_a <= end_a) and (start_b <= end_b):
        # a사람
        mid_a = int((start_a + end_a) / 2)
        if mid_a == Pa:
            win_a = True
        elif mid_a < Pa:
            start_a = mid_a + 1
        else:
            end_a = mid_a - 1
        # b사람
        mid_b = int((start_b + end_b) / 2)
        if mid_b == Pb:
            win_b = True
        elif mid_b < Pb:
            start_b = mid_b + 1
        else:
            end_b = mid_b - 1
        # 이긴사람 있나 확인
        if win_b and win_a:
            win = 0
            break
        elif win_b:
            win = "B"
            break
        elif win_a:
            win = "A"
            break

    print(f"#{stage} {win}")
```
=> 10/8

- 왤까?
    - 아하..문제를 잘읽자!! 문제에선 중앙점을 그래도 이용,,근데 내가 배운건 +1 또는 -1 하는거라 헷갈림

```py
T = int(input())
for stage in range(1, T+1):
    P, Pa, Pb = map(int, input().split())
    start_a, end_a = 1, P
    start_b, end_b = 1, P
    win_a, win_b = False, False
    win = 0
    while (start_a <= end_a) and (start_b <= end_b):
        # a사람
        mid_a = int((start_a + end_a) / 2)
        if mid_a == Pa:
            win_a = True
        elif mid_a < Pa:
            start_a = mid_a 
        else:
            end_a = mid_a 
        # b사람
        mid_b = int((start_b + end_b) / 2)
        if mid_b == Pb:
            win_b = True
        elif mid_b < Pb:
            start_b = mid_b 
        else:
            end_b = mid_b 
        # 이긴사람 있나 확인
        if win_b and win_a:
            win = 0
            break
        elif win_b:
            win = "B"
            break
        elif win_a:
            win = "A"
            break

    print(f"#{stage} {win}")
```
# GPT 피드백
### 개선해!
1. 라운드 동시 시뮬레이션으로 승부를 가르는 건 가능하지만, 이 문제의 채점 포인트는 “각자가 몇 번 만에 찾았는지”예요. 즉, **탐색 횟수(count)**를 정확히 세서 비교하는 편이 안전하고 일관됩니다.
2. 경계를 mid로 갱신하는 SWEA 규칙을 썼을 때, 단순히 start = mid / end = mid로만 하면
start+1 == end 상태에서 진전이 멈출 수 있어요(무한루프 위험).
SWEA 스타일을 쓰려면 루프 조건과 갱신 규칙을 세트로 맞춰줘야 해요:
while l != r: 와 if key <= c: r = c else: l = c 조합.

```py
T = int(input())
for stage in range(1, T+1):
    P, Pa, Pb = map(int, input().split())

    def swea_steps(P, key):
        l, r = 1, P
        cnt = 0
        # SWEA 규칙: c=(l+r)//2, key<=c면 r=c, 아니면 l=c
        # 경계가 mid로만 이동하므로 'l!=r' 조건으로 수렴시킴
        while l != r:
            cnt += 1
            c = (l + r) // 2
            if key <= c:
                r = c
            else:
                l = c
        return cnt

    ca = swea_steps(P, Pa)
    cb = swea_steps(P, Pb)

    if ca < cb:
        ans = "A"
    elif ca > cb:
        ans = "B"
    else:
        ans = 0

    print(f"#{stage} {ans}")
```
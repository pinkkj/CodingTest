# 내 IDEA
### 첫번째 아이디어
```py
T = int(input())
for stage in range(1, T+1):
    N, M = map(int, input().split())
    mat = []
    ver_mat = [[0]*N for _ in range(N)]
    for i in range(N):
        new = list(input())
        mat.append(new)
    for j in range(N):
        for i in range(N):
            ver_mat[i][j] = mat[j][i]

    for i in range(N):
        result = ""
        for j in range(0, N-M+1):
            num_h = mat[i].count(mat[i][j]) -1
            num_v = ver_mat[i].count(ver_mat[i][j]) -1
            if num_h >= 1:
                s = mat[i].index(mat[i][j])
                e = mat[i].index(mat[i][j], s+1)
                while True:
                    num_h -= 1
                    check_1 = ''.join(mat[i][s:e+1])
                    check_2 = ''.join(check_1[::-1])
                    if check_1 == check_2:
                        result = check_1
                        break
                    elif num_h >= 1:
                        e = mat[i].index(mat[i][j], e+1)
                    else:
                        break
            if num_v >= 1:
                s = ver_mat[i].index(ver_mat[i][j])
                e = ver_mat[i].index(ver_mat[i][j], s+1)
                while True:
                    num_v -= 1
                    check_1 = ''.join(ver_mat[i][s:e+1])
                    check_2 = ''.join(check_1[::-1])
                    if check_1 == check_2:
                        result = check_1
                        break
                    elif num_v >= 1:
                        e = ver_mat[i].index(ver_mat[i][j], e+1)
                    else:
                        break
        if (result != "") and (len(result) == M):
            break
    print(f"#{stage} {result}")
```
=> 10개 중 9개 정답
### 두번째 아이디어
- 무엇을 놓친걸까??
    - 첫번째, 그 리스트 전체 돌고 길이 체크하다보니... 이미 M인것도 이상한걸로 덮어씌워져서 오류가 남.
    - 두번째, 계속 똑같은 리스트에 대해 .index 하다보니 "hooohoook"의 경우 두번째 h 탐색할땐, hoook만 탐색하면되는데 hooohoook까지 다 탐색함. -> 이거 보니 분할 정복인가? 생각이 들기도함.

```py
T = int(input())
for stage in range(1, T+1):
    N, M = map(int, input().split())
    mat = []
    ver_mat = [[0]*N for _ in range(N)]
    for i in range(N):
        new = list(input())
        mat.append(new)
    for j in range(N):
        for i in range(N):
            ver_mat[i][j] = mat[j][i]
    result = ""
    for i in range(N):
        if result != "":
            break
        for j in range(0, N-M+1):
            now_h = mat[i][j::]
            now_v = ver_mat[i][j::]
            num_h = now_h.count(mat[i][j]) -1
            num_v = now_v.count(ver_mat[i][j]) -1
            if num_h >= 1:
                s = now_h.index(mat[i][j])
                e = now_h.index(mat[i][j], s+1)
                while result == "":
                    num_h -= 1
                    check_1 = ''.join(now_h[s:e+1])
                    check_2 = ''.join(check_1[::-1])
                    if (check_1 == check_2) and (len(check_1) == M):
                        result = check_1
                        break
                    elif num_h >= 1:
                        e = now_h.index(mat[i][j], e+1)
                    else:
                        break
            if num_v >= 1:
                s = now_v.index(ver_mat[i][j])
                e = now_v.index(ver_mat[i][j], s+1)
                while result == "":
                    num_v -= 1
                    check_1 = ''.join(now_v[s:e+1])
                    check_2 = ''.join(check_1[::-1])
                    if (check_1 == check_2) and (len(check_1) == M):
                        result = check_1
                        break
                    elif num_v >= 1:
                        e = now_v.index(ver_mat[i][j], e+1)
                    else:
                        break
    print(f"#{stage} {result}")
```
=> 정답

# GPT 피드백
### 🔍 1️⃣ 네 코드에서 쓸데없는 부분 diff 방식으로 수정
- ver_mat 구성 로직 단순화 (zip(*mat) 사용)
- 슬라이싱 잘못된 부분 (mat[i][j::] → mat[i][j:j+M])
- 회문 탐색을 간단히 (for i in range(N): for j in range(N-M+1) 루프)
- 불필요한 count, index 반복 제거
### ✅ 2️⃣ 이런 흐름으로 짜면 좋은 구조 (로직 설계 관점)

회문 탐색은 사실 분할정복(Divide & Conquer)보단
완전 탐색(Brute Force) + 문자열 비교 최적화 문제야.

효율과 가독성을 모두 챙기려면 이런 접근이 좋아 👇

### 💡 추천 구조 요약
1️⃣ 입력 처리 → mat, ver_mat (세로 변환은 zip으로 한 줄)<br>
2️⃣ 이중 루프 (i: 행, j: 시작 인덱스)<br>
3️⃣ 슬라이싱으로 길이 M짜리 문자열 추출<br>
4️⃣ ==[::-1]으로 회문 판단<br>
5️⃣ 찾으면 바로 break<br>

```py
T = int(input())
for stage in range(1, T+1):
    N, M = map(int, input().split())
    mat = [list(input()) for _ in range(N)]
    ver_mat = list(zip(*mat))  # 전치 행렬

    result = ""
    for i in range(N):
        for j in range(N - M + 1):
            h = ''.join(mat[i][j:j+M])
            v = ''.join(ver_mat[i][j:j+M])
            if h == h[::-1]:
                result = h
                break
            if v == v[::-1]:
                result = v
                break
        if result:
            break

    print(f"#{stage} {result}")
```

### 비교 요약

| 항목      | 기존 코드                         | 개선 코드      |
| ------- | ----------------------------- | ---------- |
| 가독성     | 중첩 while, count/index 반복으로 복잡 | 루프+슬라이싱 단순 |
| 시간복잡도   | O(N³)에 가까움 (`index` 반복)       | O(N²·M)    |
| 공간복잡도   | 동일                            | 동일         |
| 유지보수성   | 낮음                            | 높음         |
| 알고리즘 성격 | 완전탐색+조건분기                     | 완전탐색(단순명확) |
### 보고 느낀점
- 아하..! 굳이 너무 시간복잡도? 효율적으로 가지치기 하려다가 오히려 복잡해짐
- 현재 보고있는 문자를 찾아서 s~e 까지 슬라이싱 하지말고, 어차피 "M"길이니깐 시작부터 M길이까지 탐색
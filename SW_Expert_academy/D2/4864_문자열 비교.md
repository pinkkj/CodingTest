# 내코드
### 1차
```py
T = int(input())
for stage in range(1, T+1):
    str1 = input()
    str2 = input()
    check = 0
    success = len(str1)
    result = 0
    for ch in str2:
        if check == success:
            result = 1
            break

        if ch == str1[check]:
            check += 1
        elif 0 < check < (success - 1):
            check = 0
    print(f"#{stage} {result}")
```
#### 문제점
1. str1이 abc고, str2가 aaaaaabc인경우 다음에 바로 b가 안나오면 0으로 돌리기 때문에 b일때 check가 1이 되어버림
2. str2의 마지막에서 매칭이되면, result를 1로 바꾸기 전에 for문을 빠져나감

### 2차
```py
T = int(input())
for stage in range(1, T+1):
    str1 = input()
    str2 = input()
    check = 0
    success = len(str1)
    result = 0
    for i in range(len(str2)):
        if str2[i] == str1[check]:
            check += 1
            if check == success:
                result = 1
                break
        elif (0 < check < (success - 1)) and (str2[i] != str2[i-1]):
            check = 0
        elif (0 < check < (success - 1)) and (str2[i] == str2[i-1]):
            continue
    print(f"#{stage} {result}")
```
# GPT 피드백
좋은 시도야! 근데 지금 코드는 “부분 일치 후 불일치”를 처리하는 로직이 엉뚱한 조건( str2[i] 와 str2[i-1] 비교) 에 의존해서, 몇 가지 경우에 놓칠 수 있어.
### 핵심 문제
1. 리셋 조건이 잘못됨: 불일치가 나왔을 때 check(현재까지 맞춘 길이)를 어떻게 돌려놓을지는 str1의 접두사=접미사 관계로 결정해야 하는데, 현재는 str2[i] 와 str2[i-1] 같은 텍스트 자체 비교로 처리하고 있어. 이러면 예를 들어 str1="ABA", str2="AABABA" 같은 케이스에서 시작 지점을 제대로 재설정 못 할 수 있어.
2. 경계값 미처리: elif (0 < check < (success - 1)) 때문에 check == success-1 상태에서 불일치가 나오면 리셋 로직이 아예 안 타. 이러면 다음 비교가 비정상 상태에서 이어질 수 있어.

### 슬라이딩 윈도(브루트포스)
```py
T = int(input())
for stage in range(1, T+1):
    pat = input().strip()
    txt = input().strip()
    N, M = len(pat), len(txt)
    found = 0
    for i in range(M - N + 1):
        if txt[i:i+N] == pat:
            found = 1
            break
    print(f"#{stage} {found}")
```

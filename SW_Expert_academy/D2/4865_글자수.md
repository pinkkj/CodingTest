# 내 코드
```py
T = int(input())
for stage in range(1, T+1):
    str1 = set(list(input()))
    str2 = input()
    max_num = 0
    for ch in str1:
        if max_num < str2.count(ch):
            max_num = str2.count(ch)
    print(f"#{stage} {max_num}")
```

# GPT 피드백
### 핵심 피드백
1. str2.count(ch)를 두 번 호출하고 있어요. if에서 한 번, 대입에서 또 한 번 → O(M)을 두 번. 변수에 담아 한 번만 계산하세요.
2. set(list(input()))는 set(input())으로 충분해요. (리스트로 한번 더 감쌀 필요 없음)
3. 현재는 str1의 각 문자마다 str2 전체를 스캔하므로 최악 O(|set(str1)|×M).<br>
→ collections.Counter로 str2를 한 번만 세어두면 O(M) + O(|set(str1)|)로 줄어요.

```py
T = int(input())
for stage in range(1, T+1):
    str1 = set(input().strip())
    str2 = input().strip()
    max_num = 0
    for ch in str1:
        cnt = str2.count(ch)   # 한 번만 계산
        if cnt > max_num:
            max_num = cnt
    print(f"#{stage} {max_num}")
```
```py
from collections import Counter

T = int(input())
for stage in range(1, T+1):
    str1 = set(input().strip())
    str2 = input().strip()
    freq = Counter(str2)                      # str2 한 번만 스캔
    max_num = max((freq.get(ch, 0) for ch in str1), default=0)
    print(f"#{stage} {max_num}")
```

```py
from collections import Counter

s = "ABABCA"
freq = Counter(s)          # 문자별 개수 세기
# freq == {'A': 3, 'B': 2, 'C': 1}

freq['A']      # 3
freq['Z']      # 0  (없는 키는 0을 돌려줌)
freq.get('A')  # 3
freq.get('Z')  # 0
```
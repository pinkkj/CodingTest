# 내 코드
```py
T = int(input())
for stage in range(1, T+1):
    N = int(input())
    dp = [1] * ((N // 10) + 1)
    for i in range(2, (N // 10) + 1):
        dp[i] = dp[i-1] * 1 + dp[i-2] * 2
    print(f"#{stage} {dp[-1]}")
```

# GPT 풀이
완전 정답 패턴이에요 👏
이 문제는 20×N 보드를 10×20, 20×20 타일로 채우는 전형적인 DP로, 단위폭을 10으로 보면 n = N/10에 대해
- 맨 왼쪽에 20×10(= 10×20 회전) 한 장을 두는 경우 → a[n-1]
- 맨 왼쪽에 20×20을 쓰는 경우 → 배치가 두 가지(20×20 한 장, 혹은 10×20 두 장을 세로로 쌓은 형태의 좌우 대칭)라서 2*a[n-2]

이라서 점화식 a[n] = a[n-1] + 2*a[n-2], 초기값 a[0]=1, a[1]=1이 됩니다.
샘플도 딱 맞아요: n=3→5, n=5→21, n=7→85.

네 코드도 이 점화식 그대로라 정답이 나옵니다. 다만, 가독성/명확성 측면에서 몇 가지만 살짝 손보면 좋아요.

### 피드백 & 살짝 다듬은 버전
- k = N // 10로 의미를 드러내면 읽기 쉬워요.
- 초기 dp를 전부 1로 채우기보단, dp[0]=dp[1]=1을 명시하면 안전합니다(의미도 명확).
- 곱하기 1은 불필요하니 제거.
```py
T = int(input())
for tc in range(1, T+1):
    N = int(input().strip())
    k = N // 10                     # 10 단위로 환산
    dp = [0] * (k + 1)
    dp[0] = 1
    dp[1] = 1
    for i in range(2, k + 1):
        dp[i] = dp[i-1] + 2 * dp[i-2]
    print(f"#{tc} {dp[k]}")
```
# 내 코드
```py
from collections import deque
T = int(input())
for stage in range(1, T+1):
    result = 0
    V, E = map(int, input().split())
    graph = [[0]*(V+1) for _ in range(V+1)]
    for _ in range(E):
        start, end = map(int, input().split())
        graph[start][end] = 1
    s, g = map(int, input().split())
    q = deque()
    q.append(s)
    while q:
        now = q.popleft()
        if now == g:
            result = 1
            break
        # 연결되어 있는 노드 넣기!
        for num, val in enumerate(graph[now]):
            if val == 1:
                val += 1
                q.append(num)
    print(f"#{stage} {result}")
```
# GPT 피드백
### 고칠점
1. 방문 체크가 없음
- 사이클이 있는 그래프면 같은 노드를 계속 다시 넣을 수 있어요. visited 배열이 필요합니다.
2. val += 1은 효과가 없음
- for num, val in enumerate(graph[now])에서 val은 값의 복사본이라 val += 1로는 graph가 바뀌지 않아요. 애초에 간선표는 바꾸지 말고, 방문 체크만 하세요

```py
from collections import deque

T = int(input())
for stage in range(1, T+1):
    V, E = map(int, input().split())
    graph = [[0]*(V+1) for _ in range(V+1)]
    for _ in range(E):
        start, end = map(int, input().split())
        graph[start][end] = 1

    S, G = map(int, input().split())

    visited = [False]*(V+1)
    q = deque([S])
    visited[S] = True
    result = 0

    while q:
        now = q.popleft()
        if now == G:
            result = 1
            break
        # now에서 갈 수 있는 모든 정점 확인
        for nxt in range(1, V+1):
            if graph[now][nxt] == 1 and not visited[nxt]:
                visited[nxt] = True
                q.append(nxt)

    print(f"#{stage} {result}")
```
### 참고
- 복잡도: 인접행렬이라 한 정점 꺼낼 때마다 O(V) 스캔 → 대략 O(V^2). V≤50이라 충분히 OK.
- 더 빠르게 하려면 인접리스트로 바꾸세요:
```py
adj = [[] for _ in range(V+1)]
for _ in range(E):
    a,b = map(int, input().split())
    adj[a].append(b)
# 순회는 for nxt in adj[now]:
```
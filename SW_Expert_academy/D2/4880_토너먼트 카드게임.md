# 내 풀이
```py
T = int(input())
for stage in range(1, T+1):
    N = int(input())
    info = [[i+1, j] for i, j in enumerate(list(map(int, input().split())))]
    def decide_winner(first, second):
        first = first[0]
        second = second[0]
        what1 = first[1]
        what2 = second[1]
        if (what1 == 1) and (what2 == 1):
            return [[first[0], what1]]
        elif (what1 == 1) and (what2 == 2):
            return [[second[0], what2]]
        elif (what1 == 1) and (what2 == 3):
            return [[first[0], what1]]
        elif (what1 == 2) and (what2 == 1):
            return [[first[0], what1]]
        elif (what1 == 2) and (what2 == 2):
            return [[first[0], what1]]
        elif (what1 == 2) and (what2 == 3):
            return [[second[0], what2]]
        elif (what1 == 3) and (what2 == 1):
            return [[second[0], what2]]
        elif (what1 == 3) and (what2 == 2):
            return [[first[0], what1]]
        elif (what1 == 3) and (what2 == 3):
            return [[first[0], what1]]
    def who_win(list):
        i, j = 0, len(list)-1
        list1, list2 = list[0: (i+j)//2 + 1], list[(i+j)//2+1: j+1]
        while len(list1) != 1 or len(list2) != 1:
            if len(list1) == 2 and len(list2) == 1:
                list1 = who_win(list1)
            else:
                list1 = who_win(list1)
                list2 = who_win(list2)
        return decide_winner(list1, list2)
    result = who_win(info)
    print(f"#{stage} {result[0][0]}")
```

# GPT 피드백
### 어디가 문제인가?
1. who_win의 슬라이싱/while 구조
- 길이가 1인 그룹에도 who_win을 다시 호출하게 되는 분기가 있어 빈 리스트가 만들어지고, 재귀 안에서 i=0, j=-1 같은 비정상 범위가 생깁니다. 이건 무한재귀/에러의 원인입니다.
- 이 문제는 “구간 [i, j]”를 인덱스로 다루는 분할정복(재귀) 형태가 가장 안전합니다(리스트 잘라붙이기 X).

2. decide_winner의 입력/출력 형식 혼선
- 인자로 [ [id, card] ] 같은 중첩 리스트가 들어오고, 내부에서 first = first[0]로 또 벗겨 쓰는 식이라 실수가 잦아요.
- 승자는 “인덱스(번호)” 하나만 반환하면 충분합니다.

3. 불필요하게 많은 if 분기
- 가위(1)–바위(2)–보(3) 규칙은 3가지 승리 경우 + 동률 처리만 있으면 됩니다. 테이블/조건 4줄로 끝낼 수 있어요.
### 권장 구조
- winner(l, r): 구간 [l, r]의 승자 “인덱스”를 반환
- fight(a, b): 두 인덱스의 카드를 비교해 승자 인덱스를 반환

<br>이렇게 하면 빈 리스트/슬라이스가 아예 생기지 않고, N이 2의 거듭제곱이 아니어도 안전합니다.

```py
import sys
input = sys.stdin.readline

# a가 b를 이기는지 판단
def fight(a, b, cards):
    xa, xb = cards[a], cards[b]
    if xa == xb:               # 동률이면 번호가 작은 쪽 승
        return a if a < b else b
    # 1: 가위, 2: 바위, 3: 보
    # 가위(1) 이김: 보(3)
    # 바위(2) 이김: 가위(1)
    # 보(3)   이김: 바위(2)
    if (xa == 1 and xb == 3) or (xa == 2 and xb == 1) or (xa == 3 and xb == 2):
        return a
    else:
        return b

def winner(l, r, cards):
    if l == r:
        return l
    m = (l + r) // 2
    left = winner(l, m, cards)
    right = winner(m + 1, r, cards)
    return fight(left, right, cards)

T = int(input())
for tc in range(1, T + 1):
    N = int(input().strip())
    arr = list(map(int, input().split()))
    # 인덱스를 1번부터 쓰고 싶으면 앞에 dummy 하나 추가
    cards = [0] + arr
    ans = winner(1, N, cards)
    print(f"#{tc} {ans}")
```
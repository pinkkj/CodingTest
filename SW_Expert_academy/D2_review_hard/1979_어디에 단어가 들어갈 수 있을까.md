# 내 코드
```py
def check(arr, K):
    result = 0
    arr = [0] + arr + [0]
    for i in range(1, len(arr) + 2 - K):
        if (sum(arr[i:i+K]) == K) and (arr[i-1] == 0) and (arr[i+K] == 0):
            result += 1
    return result
T = int(input())
for stage in range(1, T+1):
    result = 0
    N, K = map(int, input().split())
    info = [list(map(int, input().split())) for _ in range(N)]
    re_info = [list(row) for row in zip(*info)]


    for arr in info:
        result += check(arr, K)
    for arr in re_info:
        result += check(arr, K)
    print(f"#{stage} {result}")
```
=> re_info 즉 zip을 2차원 행렬로 바꾸는 코드 숙지!!
# GPT 피드백
## 딱 하나 아쉬운 점(범위)
```py
for i in range(1, len(arr) + 2 - K):
```
이건 조금 범위가 넓게 잡혀 있어.
파이썬 and의 단락 평가 덕분에 에러는 안 나지만,
논리적으로 필요한 범위는 더 좁게 잡는 게 좋아.

패딩 후 arr 길이는 len_arr = 원래 N + 2.

우리가 접근하는 인덱스는:
- arr[i:i+K] (슬라이스는 범위 넘어가도 안전)
- arr[i-1]
- arr[i+K] ← 이건 직접 인덱스라서 i+K <= len_arr-1 이어야 안전

조건:
```text
i + K <= len_arr - 1
→ i <= len_arr - 1 - K
```

그래서 마지막 i는 len_arr - 1 - K.
range의 stop은 마지막 + 1이니까:

```py
for i in range(1, len(arr) - K):
    ...
```
## Check 함수의 다른 버전
```py
def check2(arr, K):
    result = 0
    cnt = 0
    arr = arr + [0]   # 끝 경계용 0 하나만 추가

    for x in arr:
        if x == 1:
            cnt += 1
        else:
            if cnt == K:
                result += 1
            cnt = 0
    return result
```
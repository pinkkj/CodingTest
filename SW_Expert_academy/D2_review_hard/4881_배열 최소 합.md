# 내 코드
```py
T = int(input())
def dfs(now_sum, now_stage, now_index, info, N,visited, min_num):
    if now_stage == (N-1):
        return min(min_num, now_sum)
    for i, val in enumerate(info[now_stage + 1]):
        if visited[i] or (now_sum + val > min_num):
            continue
        visited[i] = True
        min_num = dfs(now_sum+info[now_stage+1][i], now_stage+1, i, info, N, visited, min_num)
        visited[i] = False
    return min_num

for stage in range(1, T+1):
    N = int(input())
    min_num = 10*N
    info = [list(map(int, input().split())) for _ in range(N)]
    visited = [False] * N
    stack = []
    for i in range(N):
        visited[i] = True
        min_num = dfs(info[0][i], 0, i, info, N, visited, min_num)
        visited[i] = False
    print(f"#{stage} {min_num}")
```
# GPT 피드백
## 아쉬운 점 / 개선 포인트
### (1) now_index 파라미터는 안 쓰고 있어
```py
def dfs(now_sum, now_stage, info, N, visited, min_num):
    if now_stage == N-1:
        return min(min_num, now_sum)

    for i, val in enumerate(info[now_stage + 1]):
        if visited[i] or (now_sum + val > min_num):
            continue
        visited[i] = True
        min_num = dfs(now_sum + val, now_stage + 1, info, N, visited, min_num)
        visited[i] = False

    return min_num
```
### (2) min_num = 10 * N 대신 float('inf')가 더 안전해
지금 문제에선 “각 원소 < 10”이란 조건이 있어서
최대 합은 9 * N이니까 10 * N을 upper bound로 둔 건 맞긴 한데,
- 나중에 문제 조건이 바뀌면(예: 100 이하 자연수), 이 코드가 갑자기 틀어질 수 있어.
- 일반적으로는 “정말 큰 값”을 표현할 때 float('inf')를 많이 씀
```py
min_num = float('inf')
```
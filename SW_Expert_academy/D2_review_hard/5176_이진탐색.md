# 내 코드
```py
T = int(input())

def put_in_the_tree(num, node, tree, N):
    if node > N:
        return num, tree
    num,tree = put_in_the_tree(num, 2 * node, tree, N)
    tree[node] = num
    num += 1
    num,tree = put_in_the_tree(num, 2 * node + 1, tree, N)
    return num, tree

for stage in range(1, T+1):
    N = int(input())
    tree = [0] * (N+1)

    num, tree = put_in_the_tree(1,1,tree,N)
    print(f"#{stage} {tree[1]} {tree[int(N//2)]}")
```

# GPT 피드백
## 코드 스타일/개선 포인트
### (1) tree는 굳이 리턴 안 해도 됨
리스트는 mutable이라 함수 안에서 수정하면 그대로 바뀌어.
그래서 num만 리턴해도 충분해.

```py
def put_in_the_tree(num, node, tree, N):
    if node > N:
        return num
    num = put_in_the_tree(num, 2 * node, tree, N)
    tree[node] = num
    num += 1
    num = put_in_the_tree(num, 2 * node + 1, tree, N)
    return num
```
### (2) int(N//2)는 N//2만 써도 됨
// 자체가 정수 나눗셈이라 int()는 완전 중복이야.
```py
print(f"#{stage} {tree[1]} {tree[N//2]}")
```

### (3) N = 1일 때의 극단 케이스
문제 조건에 N >= 1이라 이론상 N = 1도 가능해.
- 이때 N//2 = 0 → tree[0]을 보게 됨 (지금 코드에선 0이 들어 있음)
- SWEA 채점 데이터에서 N=1이 안 나올 가능성이 크긴 한데,
혹시 신경 쓰고 싶다면 N이 1일 때만 예외 처리해줄 수도 있어:
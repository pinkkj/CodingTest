# 내 코드
```py
for stage in range(1, 11):
    N = int(input())
    mat = [list(map(int, input().split())) for _ in range(100)]
    re_mat = [list(i) for i in zip(*mat)]
    max_sum = 0
    for row in mat:
        max_sum = max(max_sum, sum(row))
    for col in re_mat:
        max_sum = max(max_sum, sum(col))
    mat_x = 0
    re_mat_x = 0
    for i in range(100):
        mat_x += mat[i][i]
        re_mat_x += re_mat[i][i]
    max_sum = max(max_sum, mat_x, re_mat_x)
    print(f"#{N} {max_sum}")
```
# GPT 피드백
## 제일 큰 문제: 대각선 하나를 잘못 구하고 있음
```py
mat_x = 0
re_mat_x = 0
for i in range(100):
    mat_x += mat[i][i]
    re_mat_x += re_mat[i][i]
```
근데 re_mat는 mat을 단순히 전치 행렬로 바꾼 거라서,
```py
re_mat[i][i] == mat[i][i]
```
항상 이렇게 돼.<br>
즉, 두 줄 모두 같은 대각선(주대각선)만 두 번 더한 꼴이야.<br>
→ 반대쪽 대각선 합은 아예 안 보고 있는 상태라,
테스트에서 반대 대각선이 제일 크면 오답 나올 수 있어.

반대 대각선은 이렇게 구해야 해:
```py
for i in range(100):
    mat_x += mat[i][i]              # (0,0), (1,1), ..., (99,99)
    re_mat_x += mat[i][99 - i]      # (0,99), (1,98), ..., (99,0)
```
## 전치 행렬(re_mat)도 사실 안 만들어도 됨
```py
# 행 합
for row in mat:
    max_sum = max(max_sum, sum(row))

# 열 합
for j in range(100):
    col_sum = 0
    for i in range(100):
        col_sum += mat[i][j]
    max_sum = max(max_sum, col_sum)
```
=> 이게 더 메모리 효율적이고, 직관적이다.
## max_sum 초기값
습관적으로는 첫 번째 행의 합으로 초기화하는 게 더 안전해:
```py
max_sum = sum(mat[0])
```
## 전체 수정 코드 예시
```py
for tc in range(1, 11):
    _ = int(input())  # 테스트케이스 번호 (1,2,...,10) 들어오지만 사실 안 써도 됨
    mat = [list(map(int, input().split())) for _ in range(100)]

    # 1) 행 최대 합
    max_sum = sum(mat[0])
    for row in mat:
        max_sum = max(max_sum, sum(row))

    # 2) 열 최대 합
    for j in range(100):
        col_sum = 0
        for i in range(100):
            col_sum += mat[i][j]
        max_sum = max(max_sum, col_sum)

    # 3) 두 대각선 합
    diag1 = 0
    diag2 = 0
    for i in range(100):
        diag1 += mat[i][i]          # 왼쪽 위 → 오른쪽 아래
        diag2 += mat[i][99 - i]     # 오른쪽 위 → 왼쪽 아래
    max_sum = max(max_sum, diag1, diag2)

    print(f"#{tc} {max_sum}")
```
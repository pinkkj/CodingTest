# 내 코드
```py
T = int(input())
for stage in range(1, T+1):
    N = int(input())
    want_A = list(map(int, input().split()))
    want_B = list(map(int, input().split()))
    info = [""] * (N+1)
    skip_A = 0
    skip_B = 0
    for i in range(N):
        if info.count("") == 1:
            break

        if info[want_A[i+skip_A]] == "":
            info[want_A[i+skip_A]] = "A"
        else:
            while info[want_A[i+skip_A]] != "":
                skip_A += 1
                if i+skip_A == N:
                    break
            if i + skip_A == N:
                break
            info[want_A[i + skip_A]] = "A"

        if info[want_B[i+skip_B]] == "":
            info[want_B[i+skip_B]] = "B"
        else:
            while info[want_B[i+skip_B]] != "":
                skip_B += 1
                if i+skip_B == N:
                    break
            if i + skip_B == N:
                break
            info[want_B[i + skip_B]] = "B"
    print("".join(info[1::]))
```
# GPT 피드백
## 아쉬운 점
### 1. info.count("")를 매 턴마다 쓰면 O(N)이라서 지금은 N ≤ 50이라 상관없지만, 습관 상으론 카운터 변수로 관리하는 게 더 좋아.

```py
remain = N
...
누가 한 명 뽑힐 때마다 remain -= 1
if remain == 0: break
```
### 2. i + skip_A / i + skip_B 구조가 읽는 사람이 이해하기 조금 힘듦 (버그는 아니고, 그냥 “머리로 시뮬레이션하기 빡센 코드”인 느낌)
- 실제로 이 문제는 “턴 수”만 세면서 각 팀 포인터를 따로 관리하는 게 더 직관적이야

## 훨씬 단순한 코드 버전 (같은 로직, 더 깔끔)
```py
T = int(input())
for _ in range(T):
    N = int(input())
    want_A = list(map(int, input().split()))
    want_B = list(map(int, input().split()))

    team = [""] * (N + 1)  # team[i] = 'A' or 'B'
    idxA = 0  # A가 현재 보고 있는 선호도 인덱스
    idxB = 0  # B가 현재 보고 있는 선호도 인덱스

    # 총 N번 뽑기 (A, B, A, B, ... 번갈아)
    for turn in range(N):
        if turn % 2 == 0:  # A 차례 (0, 2, 4, ...)
            while team[want_A[idxA]] != "":
                idxA += 1
            team[want_A[idxA]] = "A"
        else:              # B 차례 (1, 3, 5, ...)
            while team[want_B[idxB]] != "":
                idxB += 1
            team[want_B[idxB]] = "B"

    print("".join(team[1:]))
```
-> 아하, 어차피 사람 수만큼만 turn을 도니깐.... 각 팀별로 인덱스 따로 관리하고 턴을 돌아!!
# 다른 사람 코드
```py
T = int(input())
# 여러개의 테스트 케이스가 주어지므로, 각각을 처리합니다.
ans = []
for test_case in range(1, T + 1):
    n = int(input())
    A = list(map(int, input().split()))
    B = list(map(int, input().split()))
    a = 0
    b = 0
    used = [0 for _ in range(n)]
    res = ["" for _ in range(n)]
    while res.count("A") + res.count("B") < n:
        while used[A[a] - 1]:
            a += 1
        res[A[a] - 1] = 'A'
        used[A[a]-1] = 1
        if res.count('A')+res.count('B')==n: break
        while used[B[b]-1]:
            b+=1
        res[B[b] - 1] = 'B'
        used[B[b] - 1] = 1
    ans.append(res)
 
for e in ans:
    for q in e:
        print(q, end='')
    print()
```
# 내 코드
```py
T = int(input())
for stage in range(1, T+1):
    nums = list(map(int,input()))
    count = [0] * (len(nums) + 1)
    appear = [0] * (len(nums) + 1)
    now = []

    result = "yes"
    for num in nums:
        if appear[num] == 0:
            appear[num] += 1
            now.append(num)
        elif appear[num] == 1:
            appear[num] += 1
            now.remove(num)
            if count[num] != num:
                result = "no"
                break
        else:
            result = "no"
            break

        if now:
            for i in now:
                if i == num:
                    continue
                count[i] += 1
                if count[i] > i:
                    result = "no"
                    break
    if now:
        result = "no"

    print(f"{result}")
```
-> 런타임 에러...
-> 아 난 바보다. count = [0] * (len(nums) + 1) 이 아니라 count = [0] * 10으로 해야지...

```py
T = int(input())
for stage in range(1, T+1):
    nums = list(map(int,input()))
    count = [0] * 10
    appear = [0] * 10
    now = []

    result = "yes"
    for num in nums:
        if appear[num] == 0:
            appear[num] += 1
            now.append(num)
        elif appear[num] == 1:
            appear[num] += 1
            now.remove(num)
            if count[num] != num:
                result = "no"
                break
        else:
            result = "no"
            break

        if now:
            for i in now:
                if i == num:
                    continue
                count[i] += 1
                if count[i] > i:
                    result = "no"
                    break
    if now:
        result = "no"

    print(f"{result}")
```
=> 저것만 고치니 바로 통과...
# GPT 피드백
## 살짝 아쉬운/보완할 부분
### 1. inner loop에서 result = "no"가 되어도 바깥 루프는 계속 돈다
```py
if now:
    for i in now:
        ...
        if count[i] > i:
            result = "no"
            break    # 이건 for i in now 만 빠져나감
```
여기서 break는 for i in now만 탈출하고, for num in nums는 계속 돌아.
최종 출력은 어차피 "no"라서 정답이 틀리진 않지만,
불필요하게 이후 숫자들을 더 처리하게 돼.

👉 개선 방법:
```py
if now:
    for i in now:
        if i == num:
            continue
        count[i] += 1
        if count[i] > i:
            result = "no"
            break
    if result == "no":    # 바깥 루프도 끊어주기
        break
```
### 2. now를 리스트로 관리하면 remove가 O(10)`이라 괜찮긴 한데, 약간 비효율적
- 지금은 숫자가 0~9라서 최대 10개라 상관없지만,
- 비슷한 패턴을 더 큰 알파벳/숫자 집합에 일반화하면 set이나 bool 배열을 쓰는 게 더 좋을 수 있어.

### 3. 가독성 측면
- nums = list(map(int,input())) 대신 s = input().strip()으로 받은 뒤 인덱스로 돌면
- 문제의 “문자열 S”라는 의미가 더 잘 드러나고, 디버깅도 쉬워져.

## 이 문제의 더 단순한 풀이 (비교용)
이 문제는 길이가 최대 10자리 정도라서, 사실 “실시간 스트리밍”처럼 안 풀어도 돼.
각 숫자의 위치만 저장해도 충분해.

```py
T = int(input())

for _ in range(T):
    s = input().strip()

    pos = [[] for _ in range(10)]     # 각 숫자가 등장하는 인덱스들

    for idx, ch in enumerate(s):
        d = ord(ch) - ord('0')        # int(ch)와 동일
        pos[d].append(idx)

    ok = True
    for d in range(10):
        if len(pos[d]) == 0:
            continue
        if len(pos[d]) != 2:          # 정확히 두 번이 아니s면 실패
            ok = False
            break
        left, right = pos[d]
        if right - left - 1 != d:     # 두 위치 사이의 개수 = d?
            ok = False
            break

    print("yes" if ok else "no")
```
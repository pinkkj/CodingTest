# 내 코드
```py
T = int(input())
for stage in range(1, T+1):
    N, M = map(int, input().split())
    graph = {i : [] for i in range(1,N+1)}
    for _ in range(M):
        start, end = map(int,input().split())
        graph[start].append(end)
        graph[end].append(start)

    max_dist = 0
    visited = [False] * (N+1)
    def dfs(node_num, dist):
        global max_dist
        max_dist = max(dist, max_dist)
        if len(graph[node_num]) == 0:
            return
        for i in graph[node_num]:
            if visited[i]:
                continue
            visited[i] = True
            dfs(i, dist + 1)
            visited[i] = False
    for i in range(1, N+1):
        visited[i] = True
        dfs(i, 1)
        visited[i] = False
    print(f"#{stage} {max_dist}")
```
# GPT 피드백
## global / 불필요한 코드 부분
### 1) global max_dist는 굳이 필요 없음
지금은 파일 최상단에서 바로 실행하는 구조라서, for stage in ... 바깥과 안 모두 “전역 스코프”야.

- 즉, 함수 밖에선 global 안써도 되고.. 함수 안에서!!

### 2) 이 줄은 사실 필요 없음
- graph가 비어있는지 확인할 필요X
```py
def dfs(node_num, dist):
    global max_dist
    max_dist = max(dist, max_dist)
    for i in graph[node_num]:
        if visited[i]:
            continue
        visited[i] = True
        dfs(i, dist + 1)
        visited[i] = False
```
## 더 “깔끔한” 버전 예시 (global 없이)
동일한 로직을 global 없이 짜고 싶으면,
DFS가 “현재 정점에서 출발하는 최장 경로 길이”를 리턴하도록 만들면 돼.

```py
T = int(input())

for stage in range(1, T + 1):
    N, M = map(int, input().split())
    graph = {i: [] for i in range(1, N + 1)}
    for _ in range(M):
        x, y = map(int, input().split())
        graph[x].append(y)
        graph[y].append(x)

    visited = [False] * (N + 1)

    def dfs(node):
        visited[node] = True
        best = 1  # 자기 자신 포함
        for nxt in graph[node]:
            if not visited[nxt]:
                length = 1 + dfs(nxt)
                if length > best:
                    best = length
        visited[node] = False
        return best

    ans = 0
    for i in range(1, N + 1):
        ans = max(ans, dfs(i))

    print(f"#{stage} {ans}")
```
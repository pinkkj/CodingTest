# 내 코드
```py
T = int(input())
for stage in range(1, T+1):
    N, limit = map(int, input().split())
    info = [[0,0]]
    for _ in range(N):
        info.append(list(map(int, input().split())))
    max_score = 0
    def dfs(num, cal, score):
        global max_score
        if cal > limit:
            return
        max_score = max(max_score, score)
        if num == N:
            return
        dfs(num+1, cal+info[num+1][1], score+info[num+1][0])
        dfs(num+1, cal, score)
    dfs(0,0,0)
    print(f"#{stage} {max_score}")
```
# GPT 피드백
## DP(냅색)으로도 풀 수 있다는 점 (참고용)
이 문제는 사실 전형적인 0/1 Knapsack이라 DP로도 많이 풀어:

```py
T = int(input())

for tc in range(1, T + 1):
    N, L = map(int, input().split())  # N: 재료 수, L: 칼로리 제한
    ingredients = [tuple(map(int, input().split())) for _ in range(N)]  # (맛 점수, 칼로리)

    # dp[c] = 칼로리 c 이하로 만들 수 있는 최대 맛 점수
    dp = [0] * (L + 1)

    for taste, cal in ingredients:
        # 0/1 냅색: 뒤에서 앞으로 갱신
        for c in range(L, cal - 1, -1):
            dp[c] = max(dp[c], dp[c - cal] + taste)

    result = max(dp)
    print(f"#{tc} {result}")

```
# 내 코드
- 생각! 3<= N < 100000 이니, O(N) 안에는 끝내야함.
```py
T = int(input())
for stage in range(1, T+1):
    N = int(input())
    nums = list(map(int, input().split()))
    sum_of_num = 0
    max_num = 0
    stored_list = []
    check = False
    for val in nums:
        if val > 0:
            if check:
                stored_list.append(val)
                sum_stored = sum(stored_list)
                if (sum_stored >= 0) and (sum_stored > val):
                    sum_of_num += sum_stored
                else:
                    max_num = max(max_num, sum_of_num)
                    sum_of_num = val
                stored_list.clear()
                check = False
            else:
                sum_of_num += val
        else:
            stored_list.append(val)
            check = True
    max_num = max(max_num, sum_of_num)
    print(f"#{stage} {max_num}")
```
-> 21개 중 2개 정답..ㅎ

```py
T = int(input())
for stage in range(1, T+1):
    N = int(input())
    nums = list(map(int, input().split()))
    max_num = -1001
    stored_list = []
    sum_of_num = 0
    check = False
    for val in nums:
        max_num = max(max_num, val)
        if val > 0:
            if check:
                stored_list.append(val)
                sum_of_num += val
                sum_stored = sum(stored_list)
                if (sum_of_num < val):
                    max_num = max(max_num, (sum_of_num-sum_stored))
                    sum_of_num = val
                max_num = max(max_num, sum_of_num)
                stored_list.clear()
                check = False
            else:
                sum_of_num += val
                max_num = max(max_num, sum_of_num)
        else:
            sum_of_num += val
            stored_list.append(val)
            max_num = max(max_num, val)
            check = True
    max_num = max(max_num, sum_of_num)
    print(f"#{stage} {max_num}")
```
-> ㅌ..통과!
# GPT 피드백
- 아이디어 자체는 “현재까지의 합을 유지하다가, 안 좋으면 끊는다” → Kadane 알고리즘이랑 거의 동일
- 모든 수가 음수일 때도,
    - max_num에 val을 계속 갱신해줘서
    - 제일 덜 음수인 값 하나를 잘 골라줌 → OK
- 양수/음수 섞인 케이스도,
    - sum_of_num를 누적하면서,
    - 이 누적 합을 계속 max_num와 비교 → OK
## 1. 아쉬운 점 / 개선 포인트
### (1) stored_list + check 구조가 너무 복잡함
지금 구조:
- 음수가 나오면 stored_list에 쌓아둔다.
- 그 다음에 양수가 나올 때:
    - stored_list에 양수도 같이 넣고
    - sum_stored = sum(stored_list) 구하고
    - sum_of_num < val 이면 이전 것들을 버리고 새로 시작하려고 시도

이게 결국 “이전 구간을 이어갈지, 새롭게 시작할지”를 결정하는 건데,
이 논리는 한 줄로 정리할 수 있어:
- 현재 원소 val을 포함하는 최대 부분합 = max(val, 이전까지의 부분합 + val) -> **Kadane 알고리즘의 핵심식**

## 2. 이 문제의 정석 풀이 (Kadane) 비교
```py
T = int(input())
for tc in range(1, T+1):
    N = int(input())
    nums = list(map(int, input().split()))

    cur = nums[0]      # 현재 위치에서 끝나는 최대 부분합
    best = nums[0]     # 전체에서의 최대 부분합

    for x in nums[1:]:
        # 1) 이전 부분합에 이어서 x를 더할지
        # 2) 아예 x 하나로 새로 시작할지
        cur = max(x, cur + x)
        # 지금까지 본 것 중 최고값 갱신
        best = max(best, cur)

    print(f"#{tc} {best}")
```
## 3. 너 코드 기준으로 핵심 피드백 정리
1. 이 문제는 전형적인 “연속 부분합 최대” → Kadane 문제라서
- 위처럼 cur = max(x, cur + x) / best = max(best, cur) 구조로
- 깔끔하게 정리해두면 나중에 다른 문제(BOJ, 프로그래머스 등)에서도 그대로 재사용 가능.
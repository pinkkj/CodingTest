<!-- # 핵심 아이디어
### ✍️내 생각
### GPT 생각
# 내 풀이 
# GPT 풀이
# 다른 사람들 풀이 -->

# 핵심 아이디어
### ✍️내 생각
1. bfs
2. queue에 넣을때 현재 몇칸갔는지, 어딘지 함께 넣어
### GPT 생각

- maps의 1은 통로, 0은 벽.
- 시작 (0,0)에서 네 방향(상하좌우)으로 갈 수 있는 칸만 큐에 넣으면서 BFS 진행.
- 방문 시점에 거리(시작에서 몇 칸인지)를 기록.
- 목표 (n-1,m-1)에 처음 도달한 순간의 거리가 정답.
- 끝까지 못 가면 -1.
- 시간복잡도: O(n*m) / 공간복잡도: O(n*m) (n, m ≤ 100 → 충분히 빠름)
# 내 풀이 
1. 
```py
from collections import deque
def solution(maps):
    answer = 0
    raw_len = len(maps[0])
    col_len = len(maps)
    if (maps[raw_len-2][col_len-2] == 0) and (maps[raw_len-1][col_len-2] == 0) and (maps[raw_len-2][col_len-1] == 0):
        return -1
    
    def move(now_x, now_y,where,d, step):
                if (where == "dx"):
                    next_x = now_x + d
                    next_y = now_y
                else:
                    next_y = now_y + d
                    next_x = now_x
                if (0<=next_y<len(maps[0])) and (0<=next_x<len(maps)):
                    if maps[next_y][next_x] == 1:
                        queue.append((next_x,next_y,step+1))
                        maps[next_y][next_x] = 0
    
    dx_list = [-1,1]
    dy_list = [-1,1]
    queue = deque([(0,0,1)])
    maps[0][0]=0
    while queue:
        x,y,step = queue.popleft()
        if (x == (col_len-1)) and (y == (raw_len - 1)):
                answer = step
                break
        for dy in dy_list:
            move(x,y,"dy",dy,step)
        for dx in dx_list:
            move(x,y,"dx",dx,step)
    return answer

```
=> 풀긴 했는데 런타임 오류남..

2. 
```py
from collections import deque
def solution(maps):
    answer = 0
    col_len = len(maps[0])
    raw_len = len(maps)
    
    def move(now_x, now_y,d, step):
                next_x,next_y = now_x+d[0], now_y+d[1]
                if (0<=next_y<len(maps)) and (0<=next_x<len(maps[0])):
                    if maps[next_y][next_x] == 1:
                        queue.append((next_x,next_y,step+1))
                        maps[next_y][next_x] = 0
    
    d_list = [[0,1],[0,-1],[1,0],[-1,0]]
    queue = deque([(0,0,1)])
    maps[0][0]=0
    while queue:
        x,y,step = queue.popleft()
        if (x == (col_len-1)) and (y == (raw_len - 1)):
                answer = step
                break
        for d in d_list:
            move(x,y,d,step)
    if (answer == 0):
        answer = -1
    return answer
```
=> 아하 시간오류가 아니라....
- col과 raw, x와 y pair 관계가 헷갈림
- -1을 처음에 if문으로 가르면 안됨. 1x1 인 판이 있을 수도 있음.

- 좋았던 점
    - BFS로 최단거리 잘 구현.
    - 중복 방문 방지를 큐 삽입 시점에 처리 → 효율적.
    - 경계 체크 정확.

- 개선 포인트
    - 입력 변형: maps를 0으로 덮어쓰는 방식은 간단하지만, 호출자 입장에서 원본이 필요할 수 있어요. visited나 dist 배열을 따로 두면 부작용이 없습니다.

    - 시작/목표가 벽인 경우: 시작칸이나 목표칸이 0이면 바로 -1을 반환하는 가드가 있으면 좋아요.

    - 이름/좌표 일관성: raw_len → row_len 권장. 그리고 코드 전반에서 (y, x)와 (x, y) 혼용되지 않게 주석을 달거나 이름을 명확히 해두면 디버깅이 쉬워집니다. (현재 구현은 일관되게 maps[y][x]를 사용하므로 동작은 OK예요.)

    - 내부 함수 move: 클로저로 큐/맵을 캡쳐하는 것도 되지만, 성능/가독성 측면에선 루프 안에 인라인으로 두는 게 더 단순합니다.

# GPT 풀이
```py
from collections import deque

def solution(maps):
    n, m = len(maps), len(maps[0])
    # 거리 배열(0: 미방문). 시작 칸 거리=1
    dist = [[0]*m for _ in range(n)]
    q = deque()

    if maps[0][0] == 0:  # 시작이 벽이면 바로 불가
        return -1

    dist[0][0] = 1
    q.append((0, 0))

    # 상하좌우
    dirs = [(-1,0), (1,0), (0,-1), (0,1)]

    while q:
        x, y = q.popleft()

        # 목표 도달 시 바로 리턴(첫 도달이 최단거리)
        if x == n-1 and y == m-1:
            return dist[x][y]

        for dx, dy in dirs:
            nx, ny = x + dx, y + dy
            # 범위 내, 통로(1), 미방문
            if 0 <= nx < n and 0 <= ny < m and maps[nx][ny] == 1 and dist[nx][ny] == 0:
                dist[nx][ny] = dist[x][y] + 1
                q.append((nx, ny))

    return -1
```

# 다른 사람들 풀이
1.
```py
from collections import deque

def solution(maps):
    x_move = [1, 0, -1, 0]
    y_move = [0, 1, 0, -1]

    x_h, y_h = (len(maps[0]), len(maps))
    queue = deque([(0, 0, 1)])

    while queue:
        x, y, d = queue.popleft()

        for i in range(4):
            nx = x + x_move[i]
            ny = y + y_move[i]

            if nx > -1 and ny > -1 and nx < x_h and ny < y_h:
                if maps[ny][nx] == 1 or maps[ny][nx] > d + 1:
                    maps[ny][nx] = d + 1
                    if nx == x_h - 1 and ny == y_h - 1:
                        return d + 1

                    queue.append((nx, ny, d + 1))

    return -1
```
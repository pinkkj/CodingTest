# 핵심 아이디어
### ✍️내 생각
- BFS 이용!! 
- computer를 확인했는지 관리하는 list 따로 생성!
- bfs를 이용해 확인하지 않은 computer에 대해 연결되어있는 컴퓨터들 모두 확인! -> 이때, 확인할때마다 True로 변경.

### GPT 생각
- 각 컴퓨터를 정점, computers[i][j] == 1 을 간선으로 보는 무방향 그래프.
- 아직 방문하지 않은 정점 i에서 DFS/BFS를 한 번 돌면, 그 정점과 같은 네트워크에 있는 모든 정점을 한 번에 방문함.
- 따라서 “방문하지 않은 정점에서 탐색 시작한 횟수” = 네트워크 개수.
- 복잡도: 인접행렬에서의 탐색은 대략 O(n²) (n ≤ 200이므로 충분히 빠름)

# 내 풀이 
```py
from collections import deque
def solution(n, computers):
    check_list = [False] * n
    queue = deque()
    answer = 0 
    
    def bfs(now_com_index):
        computers[now_com_index][now_com_index] += 1
        for i in range(len(computers[now_com_index])):
            if computers[now_com_index][i] == 1:
                       queue.append(i)
                       computers[now_com_index][i] += 1
                       check_list[i] = True
        while queue:
            link_com = queue.popleft()
            bfs(link_com)
                
    for i in range(len(check_list)):
                       if check_list[i] == False:
                            bfs(i)
                            check_list[i] = True
                            answer = answer + 1
    return answer
```
- 개선할 점:
    - 숫자 행렬에 +해서 방문하는 것을 확인하는 대신, check list 만들어 놨으니 그걸로 확인하면 됨!
    무엇이 아쉬운가?

    1. 입력 변형(데이터 오염)
        : computers[now][now] += 1, computers[now][i] += 1로 인접행렬을 직접 수정하고 있어요.

        : 보통 코딩테스트에선 입력을 변형하지 않는 것이 안정적이고 관례적입니다.

    2. BFS를 재귀로 호출
        : 함수 이름은 bfs지만 내부에서 queue + 재귀 호출을 섞었습니다.

        : BFS는 반복문으로 큐만 사용하는 편이 명확합니다. (재귀는 DFS에 가깝죠)

    3. 전역 큐 사용
        : queue가 함수 바깥에 있어요.

        : 컴포넌트(네트워크) 단위로 지역 큐를 쓰면 사이드이펙트가 줄고, 가독성이 좋아집니다.

    4. 방문 처리 타이밍
        :이웃을 append할 때 방문 처리(check_list[i]=True)를 해주고 있어 충돌은 없지만,

        :시작 정점에 대한 방문 처리는 bfs() 바깥에서 이뤄져서 흐름이 분산되어 보여요.

        : 보통은 큐에 넣는 즉시 방문 처리로 일관되게 작성합니다.
# GPT 풀이
1. dfs
```py
def solution(n, computers):
    visited = [False] * n

    def dfs(u):
        visited[u] = True
        for v in range(n):
            if computers[u][v] == 1 and not visited[v]:
                dfs(v)

    count = 0
    for i in range(n):
        if not visited[i]:
            dfs(i)
            count += 1
    return count

```
2. bfs
```py
from collections import deque

def solution(n, computers):
    visited = [False] * n
    count = 0

    for i in range(n):
        if visited[i]:
            continue
        # CONTINE!!!!
        # 새 네트워크 시작
        count += 1
        q = deque([i])
        visited[i] = True

        while q:
            u = q.popleft()
            for v in range(n):
                if computers[u][v] == 1 and not visited[v]:
                    visited[v] = True
                    q.append(v)
    return count
```
# point

1. 입력 불변: computers 건드리지 않음.

2. BFS 일관성: 큐만 사용, 재귀 없음.

3. 방문 처리 규칙: 큐에 넣는 순간 visited=True.
# 다른 사람들 풀이
1. 
```py
def solution(n, computers):
    answer = 0
    visited = [0 for i in range(n)]
    def dfs(computers, visited, start):
        stack = [start]
        while stack:
            j = stack.pop()
            if visited[j] == 0:
                visited[j] = 1
            # for i in range(len(computers)-1, -1, -1):
            for i in range(0, len(computers)):
                if computers[j][i] ==1 and visited[i] == 0:
                    stack.append(i)
    i=0
    while 0 in visited:
        if visited[i] ==0:
            dfs(computers, visited, i)
            answer +=1
        i+=1
    return answer
```

2. 플루이드-워셜 알고리즘
```py
def solution(n, computers):
    temp = []
    for i in range(n):
        temp.append(i)
    for i in range(n):
        for j in range(n):
            if computers[i][j]:
                for k in range(n):
                    if temp[k] == temp[i]:
                        temp[k] = temp[j]
    return len(set(temp))
```
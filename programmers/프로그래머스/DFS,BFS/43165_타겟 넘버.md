# 핵심 아이디어
### ✍️내 생각
- DFS 이용! stack에 계산한 값 계속 누적
- 누적할때 []를 누적! 어느 index까지 더한 값인지 함께 저장!

### GPT 생각
- numbers[i]를 만날 때마다 두 가지 선택: 현재합 + numbers[i] 또는 현재합 - numbers[i].
- 이렇게 깊이 n까지 내려가면 총 경우의 수는 최대 2^n (n ≤ 20이라 충분히 가능).

- 같은 중간합이 여러 경로로 반복해서 등장하므로, DP(누적합의 개수를 세는 방식) 를 쓰면 중복 계산을 줄일 수 있어요.

# 내 풀이 
```py
def solution(numbers, target):
    answer = 0
    stack = [[-numbers[0],0],[numbers[0],0]]
    while stack:
        out = stack.pop()
        value = out[0]
        index = out[1]
        
        if ((index == len(numbers) - 1)):
            if (value == target):
                answer = answer + 1
        else:
            index = index + 1
            stack.append([value-numbers[index], index])
            stack.append([value+numbers[index], index])
    return answer
```
# GPT 풀이
```py
def solution(numbers, target):
    ans = 0

    def dfs(i, acc):
        nonlocal ans
        if i == len(numbers):
            if acc == target:
                ans += 1
            return
        dfs(i + 1, acc + numbers[i])
        dfs(i + 1, acc - numbers[i])

    dfs(0, 0)
    return ans

```

# 다른 사람들 풀이
1. 
```py
def solution(numbers, target):
    if not numbers and target == 0 :
        return 1
    elif not numbers:
        return 0
    else:
        return solution(numbers[1:], target-numbers[0]) + solution(numbers[1:], target+numbers[0])
```
- 미친 풀이..어떻게 이런 생각을 하지?

2. 
```py
from itertools import product
def solution(numbers, target):
    l = [(x, -x) for x in numbers]
    s = list(map(sum, product(*l)))
    return s.count(target)
```
- itertools: 효율적인 반복(iteration)"을 도와주는 함수들을 모아둔 모듈이에요.
예를 들어, 조합(combinations), 순열(permutations), 데카르트 곱(product) 등을 쉽게 만들 수 있어요.
- product: itertools.product는 데카르트 곱(Cartesian product)을 만들어 줘요. 쉽게 말하면, 여러 리스트에서 하나씩 뽑아서 만들 수 있는 모든 조합을 반환해요.

3.
```py
answer = 0
def DFS(idx, numbers, target, value):
    global answer
    N = len(numbers)
    if(idx== N and target == value):
        answer += 1
        return
    if(idx == N):
        return

    DFS(idx+1,numbers,target,value+numbers[idx])
    DFS(idx+1,numbers,target,value-numbers[idx])
def solution(numbers, target):
    global answer
    DFS(0,numbers,target,0)
    return answer
```
# 내풀이
```py
def solution(info, n, m):
    total_stuff = len(info)
    global answer
    answer = 3*total_stuff+1
    
    def dfs(num_stuff,who_steal,a_cost, b_cost):
        global answer
        if who_steal == 0:
            a_cost += info[num_stuff][0]
            if a_cost >= n:
                return
        else:
            b_cost += info[num_stuff][1]
            if b_cost >= m:
                return
            
        if (num_stuff == (total_stuff-1)):
            if answer > a_cost:
                answer = a_cost
            return
        
        dfs(num_stuff+1,0,a_cost,b_cost)
        dfs(num_stuff+1,1,a_cost,b_cost)
    
    dfs(0,0,0,0)
    dfs(0,1,0,0)
    
    if answer == 3*total_stuff+1:
        answer = -1
        
    return answer
```
=> 흠 ... 시간 초과가 난다.

# GPT 피드백
브루트포스(DFS) 방식은 물건 개수 N이 최대 40일 때 시간초과가 날 수밖에 없다는 점이고, 이 문제는 동적계획법(DP)으로 쉽게 해결

## 어떤 시간 복잡도를 목표로?
- info 길이 N ≤ 40입니다. 가능한 할당(각 물건을 A가 훔치거나 B가 훔치는 경우)은 2^N개로, N=40이면 약 1조(≈1.1e12) 조합이라 완전탐색(브루트포스) 은 불가능합니다 → 시간초과.
- n, m ≤ 120 으로 작다(상수급). 그러므로 N * max(n,m) 정도의 다항(DP) 알고리즘을 목표로 해야 합니다.<br>
→ 실제로 가능한 DP: O(N * m) 또는 O(N * n) 같은 복잡도로 풀면 충분합니다.

## 원래 코드(DFS)에서 잘못된 점 · 왜 TLE인지
주요 원인:

1. 지수 시간(2^N): 각 아이템마다 두 갈래로 분기하므로 2^N 경로를 탐색합니다. N=40이면 불가능.
2. (부수적) 중복 연산·중복 호출이 많음(메모이제이션 없음). 게다가 초기 호출을 dfs(0,0,0,0)과 dfs(0,1,0,0) 두 번 해서 루트 중복으로 비용 두 배.
3. 가지치기(prune)는 어느 정도 되어 있지만, 대부분의 경우 충분한 가지치기가 되지 않아 여전히 조합 수는 폭발합니다.<br>

논리적 버그(결과에 영향 줄 수 있음):
- 단말(leaf)에서 answer를 갱신할 때, 가지치기에서 이미 a_cost >= n 또는 b_cost >= m인 경로는 반환했으니 보통 유효한 결과만 남습니다. 다만 코드가 직관적/안전성 측면에서 깔끔하지 않습니다(예: INF 상수 사용, 전역변수 사용 등).
## 사고의 흐름
1. 완전탐색 상상 → 상태를 요약하고 싶다
- 각 물건을 A/B 중 누구에게 줄지 결정 → 본질적으로 2^N.
- 하지만 ‘경찰에 안 잡힘’이란 제약은 합계가 임계값(n, m) 미만이라는 조건.
- **이런 “합 제한” 문제가 나오면 대개 DP로 합을 상태로 잡는 게 잘 맞음(가방/부분합 류).**
2. 무엇을 상태로 잡을까?
- 최종 목표: “B도 안 잡히면서(A도 안 잡히면서) A 흔적 합 최소”.
- 그러면 상태로 B의 누적 흔적 b를 들고 다니면서, 그때 가능한 A의 최소 합을 저장하면 딱 맞음.
    - 이유: 제약(“B < m”)은 b만 보면 판단 가능.
    - 목적함수(“A 최소”)는 dp에 값으로 저장하면 됨.<br>
⭐상태를 인덱스로! 목적함수 ("A최소")는 dp에 값으로 저장!!
- 반대로 A를 상태로 잡고 B를 값으로 두어도 됨. 둘 중 더 작은 임계값 축을 상태 차원으로 잡는 게 보통 유리.
3. 상태/전이 정의
- dp[b] = B 흔적이 정확히 b일 때 가능한 A 최소 합.
- 새 물건 (ai, bi)를 처리할 때:
    - A가 훔친다 → b 그대로, A += ai
    - B가 훔친다 → b가 b+bi로 이동(단 b+bi < m), A 그대로
- 매 아이템마다 새 배열에 채워 넣는 전형적인 1차원 롤링 DP 패턴.
4. 유효성 필터링
- 경찰 조건 때문에 A < n, B < m만 유지.
- 조건을 전이할 때마다 체크하면 됨.

이렇게 자연스럽게 “합 제한 DP”(knapsack/subset sum 계열)로 귀결돼요.

## 권장 해법 — DP (설명 + 코드)
- 생각: 각 물건을 순서대로 처리하면서 현재까지 B가 남긴 흔적 총합(b) 를 상태로 삼고, 그 상태에서 달성 가능한 최소 A 흔적 합(a) 를 저장하면 됩니다.
즉, dp[b] = 최소 A 흔적(어떤 선택으로 현재까지 B 흔적이 b가 되도록 한 경우).<br>
초기: dp[0] = 0, 나머지는 INF.

- 아이템 처리(물건 i, 흔적 (ai, bi)):
    - A가 훔치면: b는 변하지 않고 a가 +ai → new_dp[b] = min(new_dp[b], dp[b] + ai)
    - B가 훔치면: b가 +bi(단, b+bi < m 이어야 유효), a는 변하지 않음 → new_dp[b+bi] = min(new_dp[b+bi], dp[b])

    => 마지막에 b가 0..m-1 범위에서 dp[b] < n 인 값들 중 최소 dp[b]가 답. 없다면 -1.

    => 시간복잡도: O(N * m) (N ≤ 40, m ≤ 120) — 충분히 빠릅니다.

```py
def solution(info, n, m):
    # info: list of [a_i, b_i]
    N = len(info)
    INF = 10**9

    # dp[b] = 최소 A 흔적으로 현재까지 B 흔적 합이 정확히 b인 경우
    # we only keep b in range [0, m-1] because b >= m -> 잡힘(무효)
    dp = [INF] * m
    dp[0] = 0

    for i in range(N):
        ai, bi = info[i]
        new_dp = [INF] * m
        for b in range(m):
            if dp[b] == INF:
                continue
            # 1) A가 훔치는 경우: B 흔적 unchanged, A += ai
            #    단, A 흔적이 n 이상이면 경찰에 잡히므로 그 경로는 더 이상 고려하지 않음.
            a_after = dp[b] + ai
            if a_after < n:              # 유효한 경우만 유지
                if a_after < new_dp[b]:
                    new_dp[b] = a_after

            # 2) B가 훔치는 경우: B 흔적 증가
            b_after = b + bi
            if b_after < m:             # 유효한 (b < m) 인 경우만
                if dp[b] < new_dp[b_after]:
                    new_dp[b_after] = dp[b]
        dp = new_dp

    # 모든 물건을 처리한 뒤: b in [0, m-1] 중 dp[b] < n 인 것에서 최소 A 흔적
    ans = min((dp[b] for b in range(m) if dp[b] < n), default=None)
    return ans if ans is not None else -1
```

# 이런 DP를 떠올리는 실전 체크리스트
- 지수 탐색이 보이는가? (각 아이템 A/B 선택) → DP로 줄일 수 있나 본다.
- 제약이 “합이 임계 미만/이하” 형태인가? → 합을 상태로 둔다.
- 최적화 목표가 한쪽 합의 최소/최대인가? → 다른 한쪽 합을 상태로 두고, 목표 합을 값으로 저장한다.
- 두 임계(n, m) 중 더 작은 쪽을 상태로 잡는 걸 우선 고려(시간·메모리 절약).
- 롤링 배열로 매 아이템마다 new_dp를 만들고 최종적으로 교체.
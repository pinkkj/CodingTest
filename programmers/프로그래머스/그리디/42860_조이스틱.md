# 핵심 아이디어
1. 상하(▲▼) 조작 최소 횟수
- 각 글자를 A → 목표 글자로 바꾸기 위해 필요한 상하 이동 횟수를 구해.

- 'A'에서 위로 ord(char) - ord('A'), 아래로 26 - (ord(char) - ord('A'))

=> 즉, min(ord(char) - ord('A'), 26 - (ord(char) - ord('A')))

2. 좌우(◀▶) 이동 최소 횟수
- 기본적으로는 오른쪽으로 쭉 가는 방법 → len(name) - 1

- 그런데 중간에 **연속된 'A'**가 있는 경우, 돌아가거나 우회하는 게 더 적을 수 있어.

예: "ABAAAB"
→ 왼쪽으로 돌아가거나, 끝에 갔다가 다시 중간으로 돌아오는 게 더 효율적일 수 있음.

그래서 i번째에서 연속된 'A'를 찾고 나서,
왼쪽으로 갔다가 다시 돌아오는 등의 우회 루트 중 최솟값을 찾아야 해.

3. enumerate

# 내가 못 푼 이유
> 어디까지 생각했는가?
- 각 알파벳을 위한 상,하 최솟 값 구하는 방법
> 생각 못한것
1. 상,하 최솟 값 구할때 아스키 코드 이용 -> ord()
2. ⭐탐욕적으로 i=0부터 name의 길이 끝까지 for문을 돌며, i까진 (왼 -> 오)로 가고, 거기부터 반대방향으로 연속된 A가 있는 곳까지 가는 걸 구하고, min()을 이용해 좌,우 최솟값 구하는 생각을 못함.
    - Q. -> 와 -> and -< 밖에 없는가? -> and <- and -> 이런건 없는가?<br>
      A. 일단, -> and <- and ->이런건 없다. 왜냐면 처음 -> 했을때 마지막에서 ->해야하는 부분도 다 끝내면 되는데, 굳이 이렇게 하면 <-이거에 의해 갔던것과 ->로 이미 간곳도 한번 더 지나가야한다. 하지만, <- and ->이런 경우는 있는 것 같다.
> 반성
- 그림으로 나타내보기.
- 상하는 알았는데 좌우는 모른 이유 -> 좌우에서 발생할 수 있는 경우의 수를 나누지 않음 => 나누고 수식적으로 표현해보기

> 실수
```py
end_of_A = i
if (end_of_A < len(name) - 1):
    while (name[end_of_A + 1] == 'A'):
        end_of_A = end_of_A + 1
```
=> 미쳤구나...end_of_A에 1을 더하는 행위를 두번했다.

# 다른 다람들 풀이
### 1번
```py
def solution(name):
    answer = 0
    min_move = len(name) - 1
    next = 0
    
    while name[min_move] == 'A' and min_move > 0:
        min_move -= 1
    
    if (min_move < 0):
        return answer
        
    for i, char in enumerate(name):
        answer += min(ord(char) - ord('A'), ord('Z') - ord(char) + 1)
        
        next = i + 1
        while next < len(name) and name[next] == 'A':
            next += 1
        
        min_move = min(min_move, i + (i + len(name)) - next)
    answer += min_move
    return answer
```
### 2번
```py
def solution(name):
    answer = 0
    minimum_move = len(name) - 1
    
    for i, char in enumerate(name):
    	# 상하 최소 조작 횟수를 구하는 부분
        answer += min(ord(char) - ord('A'), ord('Z') - ord(char) + 1)
        nxt = i + 1
        
        while nxt < len(name) and name[nxt] == 'A':
            nxt += 1
            
        # 좌우 최소 이동횟수를 구하는 부분          
        minimum_move = min([minimum_move, 2 *i + len(name) - nxt, i + 2 * (len(name) - nxt)])
        
    answer += minimum_move
    return answer
```
=> 내가 언급한, <- and -> 이 경우 추가한 거인듯.
# 내 풀이

=> 근데 문제가 생겼다. 1,2번 대로 풀었더니 오류인 케이스가 존재..!

=> 아하 내가 쓴 답에 len(name) - 1이라 적어놓음...

```py
while (name[min_move] == 'A'):
        min_move = min_move - 1
```
=> 이렇게 했더니 name[-1] 으로 오류 발생.

```py
def solution(name):
    min_move = len(name)-1
    answer = 0
    # 맨끝부터 연속적인 A가 있을때
    while min_move >= 0 and name[min_move] == 'A':
        min_move -= 1
    if min_move < 0:
        return 0  # 전부 A라면 조작 필요 없음

    
    # for문으로 돌기
    for i, char in enumerate(name):
        answer = answer + min(ord(char)-ord('A'), ord('Z') - ord(char) + 1)
        end_of_A = i + 1
        while (end_of_A < len(name) and name[end_of_A] == 'A'):
            end_of_A = end_of_A + 1
        min_move = min(min_move, 2 * i + len(name) - end_of_A, 2*(len(name)- end_of_A) + i)
    answer = answer + min_move
    return answer
```
=> 최종답.
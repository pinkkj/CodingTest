# 핵심 아이디어
- 가장 무거운 사람(j)은 무조건 보트에 태워야 함

- 남은 자리에는 가장 가벼운 사람(i)을 태울 수 있으면 같이 태움

- 그렇지 않으면 무거운 사람 혼자 태움
- 투 포인터 이용
# 내 풀이 / 틀린 이유
- 몸무게 많이 나가는 사람부터 고르기 -> max()
- limit - max() 보다 작은 사람 중 가장 큰 사람 태우기.

```py
def solution(people, limit):
    answer = 0
    people.sort(reverse=True)
    while (people):
        second_person_limit_weight = limit - people[0]
        if ((people[-1] <= second_person_limit_weight) and (len(people) !=1)):
            people.pop(0)
            people.pop(-1)
        else:
            people.pop(0)
        answer = answer + 1
        
    return answer
```
=> test case는 다 통과. 하지만, 효율성 Test는 다 실패...(시간 초과)<br>
=> 정렬을 빼볼까? -> 정렬의 시간복잡도 (O(nlogn)) (이게 문제 X)

🔍 문제 원인 -> by GPT<br> 
list.pop(0)의 시간복잡도는 O(n) 입니다.
리스트의 맨 앞 원소를 제거하면, 나머지 모든 요소가 한 칸씩 앞으로 이동하기 때문이죠.

네 코드의 while 루프 안에서 매번 pop(0)을 실행하므로
최악의 경우 O(n²)이 됩니다. (n은 최대 50,000)

```py
def solution(people, limit):
    answer = 0
    people.sort(reverse=True)
    while (people):
        
        if ((people[-1] <= (limit - people[0])) and (len(people) !=1)):
            people = people[1:len(people)-1]
        else:
            people = people[1:len(people)]
        answer = answer + 1
        
    return answer
```
📌 문제점 1: 슬라이싱의 시간 복잡도<br>
people[1:len(people)-1]은 새로운 리스트를 매번 생성합니다.
슬라이싱은 O(n) 시간이 걸리며, 반복문 안에서 실행되므로 최악의 경우 O(n²) 이 됩니다.

📌 문제점 2: 리스트의 길이가 계속 줄어들면서 매번 복사<br>
people 리스트가 클 때, 매번 슬라이싱으로 새로운 리스트를 만들기 때문에 메모리 사용량도 증가합니다.

⭐핵심아이디어는 생각해냈지만, 시간 복잡도를 줄이지 못했음.

# GPT 풀이
```py
def solution(people, limit):
    people.sort() 
    i, j = 0, len(people) - 1
    answer = 0
    
    while i <= j:
        if people[i] + people[j] <= limit:
            i += 1 
        j -= 1      
        answer += 1
    return answer
```
✅ 시간복잡도<br>
- 정렬: O(n log n)

- 투포인터 탐색: O(n)

- 총합: O(n log n) → 효율성 테스트 통과


# 다른 사람 풀이
1. Queue 이용
```py
from collections import deque

def solution(people, limit):
    result = 0
    deque_people = deque(sorted(people))

    while deque_people:
        left = deque_people.popleft()
        if not deque_people:
            return result + 1
        right = deque_people.pop()
        if left + right > limit:
            deque_people.appendleft(left)
        result += 1
    return result
```
- stack에서의 pop -> O(n) 최악
- queue에서의 pop -> 이중연결리스트이니 무조건 O(1)
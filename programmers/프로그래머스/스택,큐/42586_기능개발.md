<!-- # 핵심 아이디어

# 내 풀이 / 틀린 이유

# GPT 풀이

# 다른 사람들 풀이 -->
# 핵심 아이디어
- 남은 작업량을 속도로 나눠 올림(ceil).

- 완료 날짜 배열을 만든 뒤, 앞의 기능이 아직 배포되지 않았다면 뒤의 기능은 같이 배포.
    - 기준 배포일(max_day)을 잡고,
    - 새로운 기능의 완료일이 기준일보다 작거나 같으면 같은 배포 묶음
    - 기준일보다 크면 이전 배포 묶음을 answer에 추가하고 새 기준일로 업데이트.
- stack이 필요 없음! 단순히 max_day와 현재 배포 묶음 개수(count)만 관리하면 충분함.



# 내 풀이 / 틀린 이유
1. 
```py
def solution(progresses, speeds):
    answer = []
    stack = []
    n = 0
    for i in range(len(speeds)):
        # 얼마나 걸리나?
        if ((100-progresses[i]) % speeds[i]) != 0:
            time = ((100-progresses[i]) // speeds[i]) + 1
        else:
            time = (100-progresses[i]) // speeds[i]
        # 세기
        if ((len(stack) == 0)or (stack.pop() >= time)):
            n = n + 1
            stack.append(time)
        else:
            answer.append(n)
            stack.append(time)
            n = 1
    answer.append(n)
    return answer
```
- 틀린 이유: 기준 값이 계속 업데이트 됨. [10,1,3,20]의 경우 [3~]이 되어야 하는데 기준값이 10에서 1로 바뀌면 [2]에서 끝나버림.

2.
```py
def solution(progresses, speeds):
    answer = []
    stack = []
    n = 0
    for i in range(len(speeds)):
        # 얼마나 걸리나?
        if ((100-progresses[i]) % speeds[i]) != 0:
            time = ((100-progresses[i]) // speeds[i]) + 1
        else:
            time = (100-progresses[i]) // speeds[i]
            
        # 세기
        if ((len(stack) == 0)or (stack[0] >= time)):
            n = n + 1
            stack.append(time)
        else:
            answer.append(n)
            while (len(stack) != 0):
                stack.pop()
            print(stack)
            stack.append(time)
            n = 1
    answer.append(n)
    return answer
```
=>  통과!
# GPT 풀이
```py
def solution(progresses, speeds):
    answer = []
    # 각 기능이 완료되기까지 걸리는 일수 계산
    days = [-(p-100)//s for p, s in zip(progresses, speeds)]  # 올림 계산

    max_day = days[0]  # 기준 배포일
    count = 1          # 현재 배포 묶음 개수

    for d in days[1:]:
        if d <= max_day:
            count += 1  # 같은 배포 묶음에 포함
        else:
            answer.append(count)  # 이전 배포 묶음 종료
            max_day = d          # 기준 배포일 변경
            count = 1

    answer.append(count)  # 마지막 묶음 추가
    return answer
```
# 다른 사람들 풀이
1.
```py
# 문제가 개편되었습니다. 이로 인해 함수 구성이나 테스트케이스가 변경되어, 과거의 코드는 동작하지 않을 수 있습니다.
# 새로운 함수 구성을 적용하려면 [코드 초기화] 버튼을 누르세요. 단, [코드 초기화] 버튼을 누르면 작성 중인 코드는 사라집니다.
def solution(progresses, speeds):
    Q=[]
    for p, s in zip(progresses, speeds):
        if len(Q)==0 or Q[-1][0]<-((p-100)//s):
            Q.append([-((p-100)//s),1])
        else:
            Q[-1][1]+=1
    return [q[1] for q in Q]
```

2.
```py
def solution(progresses, speeds):
    print(progresses)
    print(speeds)
    answer = []
    time = 0
    count = 0
    while len(progresses)> 0:
        if (progresses[0] + time*speeds[0]) >= 100:
            progresses.pop(0)
            speeds.pop(0)
            count += 1
        else:
            if count > 0:
                answer.append(count)
                count = 0
            time += 1
    answer.append(count)
    return answer
```

3.
```py
import math

def solution(progresses, speeds):
    answer = []
    rest = []
    temp = []

    size = len(progresses)

    for i in progresses:
        rest.append(100 - i)

    for i in range(size):
        temp.append(math.ceil(rest[i] / speeds[i]))

    cnt = 0
    p = temp[0]
    for i in range(len(temp)):
        if p < temp[i]:
            answer.append(cnt)
            p = temp[i]
            cnt = 0
        cnt += 1
    answer.append(cnt)


    return answer
```
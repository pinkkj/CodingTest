<!-- # 핵심 아이디어

# 내 풀이 / 틀린 이유

# GPT 풀이

# 다른 사람들 풀이 -->

# 핵심 아이디어

# 내풀이

### 첫번째 시도

1. 첫번째 시도
```py
def solution(numbers):
    answer = ''
    numbers = list(map(str, numbers))
    for i in range(len(numbers)-1, 0, -1):
        max_index = 0 
        for j in range(1,i+1):
            if numbers[j][0] > numbers[max_index][0]:
                max_index = j
            elif numbers[j][0] == numbers[max_index][0]:
                a = numbers[j] + numbers[j][0]
                b = numbers[max_index] + numbers[max_index][0]
                if a > b:
                    max_index = j
        numbers[i], numbers[max_index] = numbers[max_index], numbers[i]
    numbers.reverse()
    for i in numbers:
        answer = answer + i
    return answer
```
2. 틀린 이유
- 선택정렬(O(n²))이라 n=100,000에서 시간 초과 위험이 큽니다.
- 정렬 비교 기준: a가 b 앞에 와야 하는가? ⇢ a+b > b+a 이면 a가 먼저.(아하..!)

# GPT 풀이
### 풀이 1. Comparator로 풀이
```py
from functools import cmp_to_key

def solution(numbers):
    arr = list(map(str, numbers))

    def cmp(a, b):
        if a + b > b + a:  # a가 앞에
            return -1
        if a + b < b + a:  # b가 앞에
            return 1
        return 0

    arr.sort(key=cmp_to_key(cmp))
    ans = ''.join(arr)
    return '0' if ans[0] == '0' else ans
```
- cmp_to_key → 파이썬에서 comparator를 정렬에 쓸 수 있게 변환해주는 도구.
- 왜 -1, 1, 0 을 return?
    - 비교 함수의 약속된 결과값입니다.
    - 음수(보통 -1) → 첫 번째 인자가 두 번째 인자보다 "앞에 와야 한다".
    - 양수(보통 1) → 첫 번째 인자가 두 번째 인자보다 "뒤에 와야 한다".
    - 0 → 두 원소의 순서는 같다.

### 풀이 2. 키 확장 트릭(이 문제 범위 전용; 더 간단)
```py
def solution(numbers):
    arr = list(map(str, numbers))
    arr.sort(key=lambda x: x*4, reverse=True)  # 4는 최대 자릿수
    ans = ''.join(arr)
    return '0' if ans[0] == '0' else ans
```
- 우리 문제는 숫자 이어붙이기인데, 문자열 비교는 사실상 왼쪽에서부터 자리수 우선 비교를 해주기 때문에, "x*4"로 길이를 맞춰주면 a+b vs b+a 비교와 같은 효과를 줍니다.
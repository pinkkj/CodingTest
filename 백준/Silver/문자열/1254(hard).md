# 내코드
1. 
```py
import sys
# 문자열 S에 0개 이상의 문자를 추가하여 팰린드롬 만들기
# 가능하면 가장 짧게(길이 출력)
input = sys.stdin.readline
sen = input().strip()
forward = 0
backward = -1
sen_len = len(sen)
no_match = 0
while (forward-sen_len) <= backward:
    if (sen[forward] == sen[backward]):
        forward += 1
        backward -= 1
    else:
        no_match += 1
        forward += 1
print(sen_len+no_match)
```
=> 오답... 왜지?
=> GPT 한테 힌트 부탁: 아하...abcda 이런게 반례

2. (2일뒤 다시품)
```py
import sys
input = sys.stdin.readline
sen = input().rstrip()
len_sen = len(sen)
start_point = len_sen - 1
find = False
for start in range(len_sen-1):
    compare = len_sen - 1
    tmp = start
    while (compare > tmp):
        if sen[tmp] == sen[compare]:
            tmp += 1
            compare -= 1
            find = True
        else:
            find = False
            break
    if find:
        start_point = start
        break
print(len_sen + start_point)
```
# GPT 피드백
## 아쉬운 / 위험할 수 있는 포인트
### (1) find 플래그 관리
지금은 find를 바깥에서 한 번 선언해놓고, while 안에서만 바꾸고 있어.

이게 실제로는 거의 항상 제대로 동작하긴 하는데,
find가 언제 True로, 언제 False로 끝나는지 “눈으로” 추적하기가 좀 불편해.
- 어떤 start에서 한 번이라도 mismatch가 나면 find = False가 되고
- mismatch 없이 while 탈출하면 마지막 비교에서 find = True 로 끝나니까
→ palindrome 여부에 따라 True/False가 맞게 나오긴 해.

그래도 iteration마다 상태를 명확히 초기화해주는 편이 좋음:

```py
for start in range(len_sen - 1):
    compare = len_sen - 1
    tmp = start
    find = True          # 일단 팰린드롬이라고 가정하고 시작
    while compare > tmp:
        if sen[tmp] == sen[compare]:
            tmp += 1
            compare -= 1
        else:
            find = False # 하나라도 다르면 팰린드롬 아님
            break
    if find:
        start_point = start
        break
```
### (2) range(len_sen-1) 괜찮나?
괜찮음. 근데, 가독성 측면에서라면 차라리 이렇게 쓰는 것도 방법이야:
```py
start_point = None
for start in range(len_sen):
    if is_palindrome_from(start):
        start_point = start
        break
# 아무 것도 못 찾았다면 start_point는 len_sen-1가 되어야 하니까 default 처리
```
### (3) 조금 더 파이써닉하게 쓸 수도 있어
지금 알고리즘을 그대로 유지하면서, Python 문자열 슬라이싱을 활용하면:

```py
s = input().strip()
n = len(s)

ans = 2 * n - 1  # 최악의 경우(마지막 문자만 겹치는 경우)

for i in range(n):
    if s[i:] == s[i:][::-1]:  # s[i:]가 팰린드롬인지
        ans = n + i
        break

print(ans)
```
## 지금 구조에서 살짝 수정!
```py
import sys
input = sys.stdin.readline

s = input().rstrip()
n = len(s)

start_point = n - 1

for start in range(n - 1):
    left = start
    right = n - 1
    is_pal = True
    while left < right:
        if s[left] != s[right]:
            is_pal = False
            break
        left += 1
        right -= 1
    if is_pal:
        start_point = start
        break

print(n + start_point)
```

# 정석풀이
## ✅ 팰린드롬 만들기 — “정석 풀이(KMP + LPS 배열)”
- KMP?
    - Knuth-Morris-Pratt 알고리즘
    - 긴 문자열 안에서, 어떤 패턴이 포함되어 있는지 빠르게 찾는 알고리즘.
    - 아이디어
        - 패턴 P에 대해 미리 **LPS 배열(또는 prefix function)**을 만든다.
        - 본문 T를 왼쪽에서 오른쪽으로 훑으면서,
        - 틀리면 그냥 한 칸씩 밀지 말고,“지금까지 맞았던 접두사 정보(LPS)”를 써서 한 번에 여러 칸 점프한다.
```py
import sys
input = sys.stdin.readline

s = input().strip()
rev = s[::-1] # 문자열 뒤집기
t = rev + "#" + s # 새로운 문자열 만들기

# LPS 배열 계산
lps = [0] * len(t) # 마지막 값이 S 뒤에서부터 겹치는 최대 팰린드롬 길이
j = 0

for i in range(1, len(t)):
    while j > 0 and t[i] != t[j]:
        j = lps[j-1] # 틀리면, 더 짧은 접두사로 다시 시도!!
    if t[i] == t[j]:
        j += 1
        lps[i] = j

# S의 접미사 중 팰린드롬과 일치하는 최대 길이
pal_len = lps[-1]

print(len(s) * 2 - pal_len)
```
-> DP/백트래킹으로 O(N)!!

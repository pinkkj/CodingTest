# 내코드
1. 
```py
import sys
# 문자열 S에 0개 이상의 문자를 추가하여 팰린드롬 만들기
# 가능하면 가장 짧게(길이 출력)
input = sys.stdin.readline
sen = input().strip()
forward = 0
backward = -1
sen_len = len(sen)
no_match = 0
while (forward-sen_len) <= backward:
    if (sen[forward] == sen[backward]):
        forward += 1
        backward -= 1
    else:
        no_match += 1
        forward += 1
print(sen_len+no_match)
```
=> 오답... 왜지?
=> GPT 한테 힌트 부탁: 아하...abcda 이런게 반례

2. (2일뒤 다시품)
```py
import sys
input = sys.stdin.readline
sen = input().rstrip()
len_sen = len(sen)
start_point = len_sen - 1
find = False
for start in range(len_sen-1):
    compare = len_sen - 1
    tmp = start
    while (compare > tmp):
        if sen[tmp] == sen[compare]:
            tmp += 1
            compare -= 1
            find = True
        else:
            find = False
            break
    if find:
        start_point = start
        break
print(len_sen + start_point)
```
# GPT 피드백
## 아쉬운 / 위험할 수 있는 포인트
### (1) find 플래그 관리
지금은 find를 바깥에서 한 번 선언해놓고, while 안에서만 바꾸고 있어.

이게 실제로는 거의 항상 제대로 동작하긴 하는데,
find가 언제 True로, 언제 False로 끝나는지 “눈으로” 추적하기가 좀 불편해.
- 어떤 start에서 한 번이라도 mismatch가 나면 find = False가 되고
- mismatch 없이 while 탈출하면 마지막 비교에서 find = True 로 끝나니까
→ palindrome 여부에 따라 True/False가 맞게 나오긴 해.

그래도 iteration마다 상태를 명확히 초기화해주는 편이 좋음:

```py
for start in range(len_sen - 1):
    compare = len_sen - 1
    tmp = start
    find = True          # 일단 팰린드롬이라고 가정하고 시작
    while compare > tmp:
        if sen[tmp] == sen[compare]:
            tmp += 1
            compare -= 1
        else:
            find = False # 하나라도 다르면 팰린드롬 아님
            break
    if find:
        start_point = start
        break
```
### (2) range(len_sen-1) 괜찮나?
괜찮음. 근데, 가독성 측면에서라면 차라리 이렇게 쓰는 것도 방법이야:
```py
start_point = None
for start in range(len_sen):
    if is_palindrome_from(start):
        start_point = start
        break
# 아무 것도 못 찾았다면 start_point는 len_sen-1가 되어야 하니까 default 처리
```
### (3) 조금 더 파이써닉하게 쓸 수도 있어
지금 알고리즘을 그대로 유지하면서, Python 문자열 슬라이싱을 활용하면:

```py
s = input().strip()
n = len(s)

ans = 2 * n - 1  # 최악의 경우(마지막 문자만 겹치는 경우)

for i in range(n):
    if s[i:] == s[i:][::-1]:  # s[i:]가 팰린드롬인지
        ans = n + i
        break

print(ans)
```
## 지금 구조에서 살짝 수정!
```py
import sys
input = sys.stdin.readline

s = input().rstrip()
n = len(s)

start_point = n - 1

for start in range(n - 1):
    left = start
    right = n - 1
    is_pal = True
    while left < right:
        if s[left] != s[right]:
            is_pal = False
            break
        left += 1
        right -= 1
    if is_pal:
        start_point = start
        break

print(n + start_point)
```
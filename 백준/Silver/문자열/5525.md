# 내 코드
```py
import sys
# I: N+1개 / O: N개
# Pn: I와 O가 교대로 나(무조건 I부터 시작)
# 입력: I,O로만 이루어진 문자열 S / N
# 출력: S안에 Pn이 몇 군데? -> 슬라이딩?
# 시간복잡도: O(N)이나 최대 O(NlogN)?
input = sys.stdin.readline
N = int(input())
M = int(input())
sen = input().strip()
stack = []
num = {"I": 0, "O": 0}
result = 0
new = 0
# I고 stack이 비어있으면 append
# stack이 차있으면, -1이 본인과 같은지 계속 확인 -> 다르면 갯수더하고 append -> 이때 I와 O의갯수가 P의 갯수와 일치하면 result+=1하고, num_I = 1, num_O=0으로 초기화,
# 근데! stack이 차있는데 본인과 같은거면 stack 비우고 다 초기화
for ch in sen:
    if not stack:
        if ch == 'I':
            stack.append(ch)
            num["I"] += 1
    else:
        if ch != stack[-1]:
            stack.append(ch)
            num[ch] += 1
            if (num["I"] == N+1+new) and (num["O"] == N+new):
                result += 1
                new += 1
        else:
            if ch == "I":
                stack.append(ch)
                num["I"] = 1
                num["O"] = 0
            else:
                num["I"] = 0
                num["O"] = 0
            new = 0
print(result)
```
- 시간복잡도: O(N)
- 주의: IOIOIOI 일때, N이 1이면, p는 3개!! 즉, 겹치는 것도 세야함.
# GPT 피드백
## 굳이 개선하자면 (간단 버전 아이디어)
- 이 문제의 전형적인 풀이 패턴은: "IOI"가 몇 개 연속으로 붙어 있는지 세고, 그 연속 개수를 통해 PN 개수를 계산한다
- 예를 들어, IOIOIOI 에서:
    - "IOI" 3개 연속 → N=2(P2)라면 가능한 PN 개수 = 3 - 2 + 1 = 2 (겹치는 것 포함)
```py
import sys
input = sys.stdin.readline

N = int(input()) # N의 의미: IOI가 몇번 반복되냐?
M = int(input())
S = input().strip()

i = 0
cnt = 0     # 연속된 "IOI" 개수
ans = 0

while i < M - 2:
    if S[i:i+3] == "IOI":
        cnt += 1
        if cnt >= N:
            ans += 1
        i += 2   # "IOI"에서 다음 패턴은 'I'부터 보게 이동
    else:
        cnt = 0
        i += 1

print(ans)
```
## 코드에서 아쉬운 점/리팩토링 포인트
### 1. stack이 실제로는 필요 없긴 함
- stack[-1] 확인하려고 쓰는데, 사실 “마지막 문자”만 알면 되니까
last_char 하나만 따로 두면 공간 O(1)로 줄일 수 있어.
- 하지만 문제 제한(1e6)에서는 현재 코드도 메모리 충분히 여유 있어서 큰 문제는 아님.
### 2. num = {"I": 0, "O": 0} → 그냥 두 개 변수로 써도 됨
```py
cnt_I = 0
cnt_O = 0
```
딕셔너리는 약간 느리고 오버헤드가 있어서, 실전에서는 가능한 기본 타입으로 쪼개 쓰는 걸 많이 선호하긴 해.
### 3. new 변수 이름이 조금 애매함
- 역할: “지금 이 구간에서 앞에서 이미 PN 하나 찾았고, 이어서 겹치는 PN이 몇 개째인지”를 표현
- 예를 들어 overlap 같은 이름이었으면 나중에 봐도 바로 이해됐을 듯.
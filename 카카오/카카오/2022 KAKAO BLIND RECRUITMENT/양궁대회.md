# 핵심 아이디어
- 라이언이 n개의 화살을 모두 쏘는 모든 경우의 수를 구해서 그중 라이언이 우승하는 경우만 고려하면 될 것.
    - 모든 경우의 수를 구하기 위해서 DFS 알고리즘을 사용하면 될 것
    - 상태 트리를 뻗어나가기 위해서 라이언은 화살을 쏠 때, 어피치가 k점을 맞춘 횟수보다 1만큼 더 쏘거나 아니면 아예 쏘지 않거나 이 두가지로 뻗어나가면 될 것

# 다른 사람 풀이
1. dfs
```py
def solution(n, info):
    global max_gap, answer
    
    answer = [-1]
    score = [0]*11
    max_gap=0
    
    def is_winner_with_gap(score):
        a=0 # 어피치 점수
        b=0 # 라이언 점수
        
        for i in range(len(info)):
            if info[i] > 0 or score[i] > 0:
                if info[i]>=score[i]:
                    a += (10-i)
                else:
                    b += (10-i)
        return (b > a, abs(a-b))

    def dfs(L, cnt):
        global max_gap, answer
        if L == 11 or cnt == 0:    
            is_winner, gap = is_winner_with_gap(score)
            if is_winner:
                if cnt >= 0: # 화살이 남은 경우
                    score[10] = cnt # 0점에 쏴도 이김
                
                if gap > max_gap: # 갭이 더 큰 경우로 업데이트
                    max_gap = gap
                    answer = score.copy()
                    
                elif gap == max_gap: # 가장 낮은 점수를 많이 맞힌 경우로 업데이트
                    for i in range(len(score)):
                        if answer[i] > 0:
                            max_i_1 = i
                        if score[i] > 0:
                            max_i_2 = i
                    if max_i_2 > max_i_1:
                        answer = score.copy()
                    
            return
        
        # k점을 어피치보다 많이 맞추거나 아예 안맞추거나
        if cnt>info[L]:
            score[L]=info[L]+1
            dfs(L+1, cnt-(info[L]+1))
            score[L]=0
            
        dfs(L+1, cnt)
    
    dfs(0,n)
    
    return answer
```

2. 
```py
def solution(n, info):
    global answer, result

    def score(ryan):
        s = 0
        for i in range(11):
            if ryan[i] == info[i] == 0:
                continue
            if ryan[i] > info[i]:
                s += 10 - i
            else:
                s -= 10 - i
        return s

    def dfs(idx, left, ryan):
        global answer, result
        if idx == -1 and left: #left가 0이면 False # 실패니깐 취소하기 정도..
            return
        if left == 0:
            s = score(ryan)
            if result < s:
                answer = ryan[:]
                result = s
            return
        for i in range(left, -1, -1):
            ryan[idx] = i
            dfs(idx-1, left-i, ryan)
            ryan[idx] = 0 # 깨끗하게 돌려놓기!!!!

    answer = [0 for _ in range(11)]
    result = 0
    dfs(10, n, [0 for _ in range(11)])
    return answer if result != 0 else [-1]
```

3. 
```py
from itertools import combinations_with_replacement
from collections import Counter
def solution(n, info):
    maxdiff,max_comb=0,{}
    for combi in combinations_with_replacement(range(11), n):
        cnt=Counter(combi)
        score1, score2=0,0
        for i in range(1, 11):
            if info[10-i]<cnt[i]: score1+=i
            elif info[10-i]>0: score2+=i
        diff=score1-score2
        if diff>maxdiff:
            max_comb=cnt
            maxdiff=diff
    if maxdiff>0:
        answer=[0]*11
        for n in max_comb:
            answer[10-n]=max_comb[n]
        return answer
    else: return [-1]
```

4.
```py
def compare(arr1, arr2) :
    idx = 10
    while idx >= 0 :
        if arr1[idx] > arr2[idx] :
            return 1
        elif arr1[idx] < arr2[idx] :
            return 0
        else :
            idx -= 1
    return -1

def cal(arr1, arr2) :
    res = 0
    for i in range(len(arr2)) :
        if arr1[i] > arr2[i] :
            res += 10 - i
        elif arr1[i] < arr2[i]:
            res -= (10 - i)
    return res

def dfs(info, idx, cand, arr, n) :
    if idx == 10 and n >= 0 :
        cur = arr + [n]
        total = cal(cur, info)
        if total > cand[0] :
            cand[0] = total
            cand[1] = cur
        elif total == cand[0] :
            if compare(cur, cand[1]) :
                cand[1] = cur
    if n < 0 or idx == 11:
        return
    dfs(info, idx+1, cand, arr + [info[idx] +1], n - (info[idx] + 1))
    dfs(info, idx+1, cand, arr + [0], n)

def solution(n, info):
    answer = []
    cand = [0, [0]*11]
    dfs(info, 0, cand, [], n)
    if cand[0] == 0 :
        return [-1]
    else :
        return cand[1]
```

# 내 풀이(다른 사람들 풀이 보고 생각)
```py
def solution(n, info):
    global max_gap
    global answer
    max_gap = 0
    answer = [-1]
    ryan = [0] * 11
    # dfs 함수
    def dfs(index, left, person):
        global max_gap, answer
        if index == 10 and left != 0:
            person[index] = left
            left = 0
        if index == 10:
            if left != 0:
                person[index] = left
                left = 0
            apeach_score = 0
            ryan_score = 0
            # 점수 계산
            for i in range(len(person)):
                if info[i] != 0 or person[i] != 0:
                    if info[i] >= person[i]:
                        apeach_score += (10-i)
                    else:
                        ryan_score += (10-i)
            # 이겼나?
            if ryan_score > apeach_score:
                gap = ryan_score - apeach_score
                if gap > max_gap:
                    answer = person.copy()
                    max_gap = gap
                elif gap == max_gap:
                    index = len(person) - 1
                    while person[index] == answer[index]:
                        index -= 1
                    if person[index] > answer[index]:
                        answer = person.copy()
            person[index] = 0
            return
        else:
            if left >= info[index] + 1:
                person[index] = info[index] + 1 # 쏘기
                dfs(index+1, left - (info[index]+1), person)
            person[index] = 0 # 안쏨
            dfs(index+1, left, person)
            
    # 처음 dfs 함수 호출
    dfs(0, n, ryan)
    return answer
```